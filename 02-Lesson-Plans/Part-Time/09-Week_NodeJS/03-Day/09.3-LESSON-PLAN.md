# Lesson Plan: Asynchronous JavaScript (10:00 AM) <!--links--> &nbsp; [‚¨ÖÔ∏è](../../09-Week_NodeJS/02-Day_ES6/09.2-LESSON-PLAN.md) &nbsp; [‚û°Ô∏è](../../10-Week/01-Day/01-Day-LessonPlan.md)

## Overview

In this lesson, we will review callback functions and introduce Promises and async/await.

## Instructor Notes

* Complete activities `31-Stu_Callback-Review` through `40-Stu_Mini-Project`

* While you would have naturally explained Promises and asynchronous behavior on a need to know basis before today, now is the time to dive deep and provide more thorough instruction for these topics.

* The most important concept for students to walk away from today understanding better is Promises. If they struggle to understand async/await, assure them that a deeper understanding of Promises makes async/await easier to grasp.

* Congratulate the class on any wins today, many JavaScript developers working in the field are unable to accurately explain many of the topics we'll be covering.

## Learning Objectives

* Describe three approaches for handling asynchronous behavior with JavaScript

* Utilize the axios library to perform AJAX requests

* Chain Promises together to perform asynchronous operations in sequence

* Utilize the Promise constructor to wrap asynchronous behavior in Promise objects.

* Utilize async/await syntax to write asynchronous code

## Slides

## Time Tracker

[Unit 09-NodeJS Time Tracker](https://docs.google.com/spreadsheets/d/1rf4sCQ7lyZAg9LLEtHe7d3lVklgF4mCu3fmGvVF8kQo/edit?usp=sharing)

---

## Class Instruction

### 1. Instructor Do: Preview (10 mins)

* Welcome the class to our final lesson of Node.js.

  * The focus of today will be all things async.
  
  * We'll dive deep into asynchronous callback functions, as well as Promises, special objects used in JavaScript handling asynchronous behavior.

* Ask the class the following question(s) and call on students for the corresponding answer(s):

  * ‚òùÔ∏è What are some examples of asynchronous behavior we've encountered so far with JavaScript?

  * üôã Making AJAX requests, timers, responding to browser events such as clicks, reading/writing to the filesystem.

  * Working with asynchronous code can be more confusing than working with synchronous code, but much of the most essential functionality in web applications happens asynchronously.

  * Since the JavaScript runtime is single-threaded, we need to write asynchronous code effectively in order to avoid blocking client requests on the server.

  * We'll conclude this lesson with a mini project where students will build a portfolio generating command-line tool.

* Without showing any of the code, take a few minutes to demonstrate the completed [40-Stu_Mini-Project/Solved/Bonus/index.js](../../../../01-Class-Content/09-NodeJS/01-Activities/40-Stu_Mini-Project/Solved/Bonus/index.js).

  * The application should prompt for some basic information such as a name and hobbies.
  
* Ask volunteers to offer up answers to each question.

* Once all the prompts have been answered, there should be a new `index.html` file added to the project directory. Open it in your web browser for the class to see.

  * This assignment is similar to their homework in which they'll use similar techniques to generate a PDF resume.

  * Many professional developers don't understand the topics we'll be covering well. By walking away from today with an understanding of the material, students will set themselves up to be more competitive in the job market.

* Answer any high-level questions about the Mini Project or lesson ahead before students begin the first activity of the day.

### 2. Students Do: Callback Review (10 mins)

* Direct students to the instructions found in [31-Stu_Callback-Review](../../../../01-Class-Content/09-NodeJS/01-Activities/31-Stu_Callback-Review/README.md):

```md
# Callback Review

In this activity, you will write code to read a file containing a list of dogs and cats and write two new files to separate dog and cat entries.

## Instructions

* Open the `Unsolved/index.js` file and take a moment to examine the provided code:

  * The `fs.readFile` method is being used to read the `animals.json` file.

  * Since the JSON data retrieved using `fs.readFile` is a string, we're calling `JSON.parse` to parse the string to a JSON object.

  * We're allocating two empty arrays called `dogs` and `cats`.

* After understanding the provided code, write code to loop through `animalJSON` and for each animal object, check its `species` property. If an animal is a `dog`, push it to the `dogs` array, else push it to the `cats` array.

* After looping through every animal, convert both the `dogs` and `cats` arrays to JSON strings using `JSON.stringify`. Save the stringified versions of the arrays to new variables.

* Then, save the JSON string version of the `dogs` array to a new `dogs.json` file. Print a message after this completes indicating that it was successful.

* Then, save the JSON string version of the `cats` array to a new `cats.json` file. Print a message after this completes indicating that it was successful.

* You can verify that you've successfully completed this activity if after running your code you have a `dogs.json` file containing only dogs and a `cats.json` object containing only cats.

## üí°Hints

* Check out the [`fs.writeFile` documentation](https://nodejs.org/api/fs.html#fs_fs_writefile_file_data_options_callback). Keep in mind that the async version will utilize Promises rather than callbacks.

* Check out the [`JSON.parse` documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse)

* Check out the [`JSON.stringify` documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)
```

### 3. Instructor Do: Review Callbacks Activity (5 mins)

* Use the prompts and talking points below to demonstrate the following key point(s):

  * ‚úîÔ∏è Callbacks are often used to handle asynchronous behavior, but callbacks themselves aren't asynchronous

* Open the [31-Stu_Callback-Review/Solved/index.js](../../../../01-Class-Content/09-NodeJS/01-Activities/31-Stu_Callback-Review/Solved/index.js) in your editor:

  ```js
  const fs = require("fs");

  fs.readFile("animals.json", "utf8", function(err, data) {
    if (err) {
      throw err;
    }

    // Parse the JSON string to an object
    const animalJSON = JSON.parse(data);

    // Create two new arrays to contain the cats and dogs objects
    const dogs = [];
    const cats = [];

    // For each element in animal
    animalJSON.forEach(function(animal) {
      if (animal.species === "dog") {
        dogs.push(animal);
      } else if (animal.species === "cat") {
        cats.push(animal);
      }
    });

    // Turn the arrays into JSON strings so they can be written to files
    const dogJSON = JSON.stringify(dogs, null, 2);
    const catJSON = JSON.stringify(cats, null, 2);

    fs.writeFile("dogs.json", dogJSON, function(err) {
      if (err) {
        throw err;
      }

      console.log("Successfully wrote to dogs.json file");
    });

    fs.writeFile("cats.json", catJSON, function(err) {
      if (err) {
        throw err;
      }

      console.log("Successfully wrote to cats.json file");
    });
  });
  ```

* Demonstrate the following key point(s):

  * üîë We're using the `fs.readFile` function to read the contents of `animals.json`. All the other code is written inside of the `fs.readFile` callback function to ensure it only runs after `animals.json` has been read.

  * üîë Since any data read with `fs.readFile` comes back as a string, we're using the `JSON.parse` method to turn the JSON string into a JSON object we can work with.

  * üîë We're using the `forEach` method to loop through the `animalJSON` and push each animal into either the `dogs` or `cats` array.

  * üîë Once the animals are pushed into their appropriate arrays, we're using `JSON.stringify` to turn the arrays into strings that can be saved to files. The additional arguments passed to JSON.stringify (`null, 2`) ensures that the JSON string is indented rather than all on one line.

  * üîë The `fs.writeFile` method is used to write the `dogs.json` and `cats.json` files.

* Ask the class the following question(s) and call on students for the corresponding answer(s):

  * ‚òùÔ∏è Which of these callback functions are asynchronous? Which are synchronous?

  * üôã The callbacks used with `fs.readFile` and `fs.writeFile` are asynchronous, but the callback used with `forEach` is synchronous.

  * Callback functions themselves aren't asynchronous any more than regular named functions are.

  * Callback functions _are_ often used to describe behavior that should happen at a later time. But in the case of `forEach`, the provided function is run once for each element in the array in a synchronous loop. The callback function is run right away, there's nothing to wait for.

  * In the case of `fs.readFile`, it takes a certain amount of time to read from the filesystem and the data isn't immediately ready. So the callback function passed into `fs.readFile` is considered asynchronous since it might run after a few milliseconds, a second, or even a minute. Any remaining synchronous code will continue running while the filesystem is being read without waiting for it.

  * When in doubt whether a callback is running synchronously or asynchronously, checking the documentation for the function being used would be a good idea.

* Answer any questions before proceeding to the next demo.

### 4. Instructor Do: Axios Demo (5 mins)

* Use the prompts and talking points below to demonstrate the following key point(s):

  * ‚úîÔ∏è Axios works similarly to `$.ajax` in jQuery

  * ‚úîÔ∏è Axios is a third party npm package so must be installed and required

* Ask the class the following question(s) and call on students for the corresponding answer(s):

  * ‚òùÔ∏è How have we performed AJAX requests in the past?

  * üôã We used the jQuery `ajax` method.

  * ‚òùÔ∏è When writing server-side code, can we use jQuery?

  * üôã No, jQuery is a front-end library. It depends on certain browser APIs that don't exist in a node context.

  * While jQuery can be downloaded as a node module, it's not meant for use on the backend, so we need another solution such as the axios library.

* Open [32-Ins_Axios-Demo/index.js](../../../../01-Class-Content/09-NodeJS/01-Activities/32-Ins_Axios-Demo/index.js) in your editor and walk the class through the small amount of code:

  ```js
  const axios = require("axios");

  axios
    .get("https://www.omdbapi.com/?t=The%20Matrix&apikey=trilogy")
    .then(function(res) {
      console.log(res.data);
    });
  ```

  * üîë We're requiring the `axios` library. Axios is a third-party npm package, i.e. it's not built-in to node.

  * üîë Axios has a `get` method that works similarly to the `$.get` in jQuery. It expects to be provided a URL endpoint to query.

  * üîë Similar to jQuery's `$.ajax`, an axios query returns a Promise object. More on this shortly, but for now it's important to know that we use `.then` to handle the response from the AJAX request.

* Run the `index.js` file and demonstrate the output in your console.

* Answer any questions before the next activity.

### 5. Students Do: Axios (10 mins)

* Direct students to the instructions found in [32-Stu_Axios/README.md](../../../../01-Class-Content/09-NodeJS/01-Activities/33-Stu_Axios/README.md):

```md
# Axios

In this activity, you will utilize the axios library to make a request to the Github API and save a list of all of your repositories.

## Instructions

* Change directories into the `Unsolved` folder and run `npm install` from your terminal.

* Once the project dependencies finish installing, examine the starter code in `Unsolved/index.js`:

  * The provided starter code prompts the user for their GitHub username and then uses the answer to construct a URL that can be used to query the GitHub API.

* Use the `axios` module to send a GET request to the `queryUrl`. The response object returned from the request should contain a `data` property which should be an array of the user's GitHub repos.

* Loop through the array of repositories and save only the names of the repositories to an array.

* Join the array of repository names to a string separated with a newline character (`\n`).

* Save the string containing the repository names to a new `repos.txt` file. Once this completes, print a message to the console indicating the number of repositories saved.

* You'll be able to verify that you've successfully completed this activity if your code successfully saves a list of all of a given user's GitHub repos.

## üí° Hints

* Take a look at the API response from the GitHub API to get an idea of how the data is structured. Example: <https://api.github.com/users/fabpot/repos?per_page=100>.

  * Avoid continually refreshing this page since there's a limit for non-authenticated requests to the GitHub API.

* Check out the [`fs.writeFile` documentation](https://nodejs.org/api/fs.html#fs_fs_writefile_file_data_options_callback). Keep in mind that the async version will utilize Promises rather than callbacks.

* Check out the [axios documentation](https://github.com/axios/axios) and look for examples for the `get` method.
```

### 6. Instructor Do: Review Axios (5 mins)

* Use the prompts and talking points below to demonstrate the following key point(s):

  * ‚úîÔ∏è Axios works similarly to `$.ajax` in jQuery

  * ‚úîÔ∏è Axios is a third party npm package so must be installed and required

  * ‚úîÔ∏è We can use the `Array.prototype.map` method to turn the array of repo objects into an array of strings containing the repo names.

  * ‚úîÔ∏è Similarly to asynchronous callbacks, we can nest Promises as a way to control the order of asynchronous code.

* Run the [33-Stu_Axios/Solved/index.js](../../../../01-Class-Content/09-NodeJS/01-Activities/33-Stu_Axios/Solved/index.js) file and ask a volunteer for their GitHub username to use for the inquirer prompt. When the response comes back from the API you should have a `repo.txt` file populated with all repositories belonging to the provided username.

* Open [33-Stu_Axios/Solved/index.js](../../../../01-Class-Content/09-NodeJS/01-Activities/33-Stu_Axios/Solved/index.js) in your editor:

  ```js
  const fs = require("fs");
  const axios = require("axios");
  const inquirer = require("inquirer");

  inquirer
    .prompt({
      message: "Enter your GitHub username:",
      name: "username"
    })
    .then(function({ username }) {
      const queryUrl = `https://api.github.com/users/${username}/repos?per_page=100`;

      axios.get(queryUrl).then(function(res) {
        const repoNames = res.data.map(function(repo) {
          return repo.name;
        });

        const repoNamesStr = repoNames.join("\n");

        fs.writeFile("repos.txt", repoNamesStr, function(err) {
          if (err) {
            throw err;
          }

          console.log(`Saved ${repoNames.length} repos`);
        });
      });
    });
  ```

* Point out the following key point(s):

  * üîë In order to get just the repository names and not all of the JSON data, we're using the `map` method to return the repository names into the `repoNames` array.

  * üîë By calling `axios.get` inside of the `.then` of the `inquirer.prompt`, we can ensure that `axios.get` is called _after_ a response has been provided to `inquirer.prompt`. Similarly, by calling `fs.writeFile` inside of the `.then` of `axios.get`, we can ensure that the file is only written after a response have been received from the API.

* Answer any questions before moving on to the next demonstration.

### 7. Instructor Do: Introduce Promises (5 mins)

Use the prompts and talking points below to demonstrate the following key point(s):

* ‚úîÔ∏è Promises are JavaScript objects that can be used to control the flow of asynchronous code.

* ‚úîÔ∏è We've used Promises before, mostly with jQuery's AJAX method.

* Ask the class the following question(s) and call on students for the corresponding answer(s):

  * ‚òùÔ∏è When have we used Promises in the past?

  * üôã When we used the jQuery `ajax` method, and when we used `axios`.

  * ‚òùÔ∏è How are Promises _visually_ different than asynchronous callbacks?

  * üôã Promises use a `.then` method to describe what should happen once the async code completes.

* Review the following key point(s):

  * üîë Any time we wrote code that used `.then`, we were working with a Promise object.

  * üîë Promises are returned from `$.ajax` method, as well as the `axios.get` method. Promises have a `.then` method that accept a function to execute when the data is ready.

  * üîë Promises have a few advantages to asynchronous callbacks alone, some of which may not be immediately apparent, but we'll work up to that.

* Open [34-Ins_Introduce-Promises/index.js](../../../../01-Class-Content/09-NodeJS/01-Activities/34-Ins_Introduce-Promises/index.js) in your editor:

  ```js
  const fs = require("fs");
  const util = require("util");

  // The built-in util package can be used to create Promise-based versions of functions using node style callbacks
  const readFileAsync = util.promisify(fs.readFile);
  const writeFileAsync = util.promisify(fs.writeFile);

  readFileAsync("animals.json", "utf8").then(function(data) {
    // Parse the JSON string to an object
    const animalJSON = JSON.parse(data);

    // Create two new arrays to contain the cats and dogs objects
    const dogs = [];
    const cats = [];

    // For each element in animal
    animalJSON.forEach(function(animal) {
      if (animal.species === "dog") {
        dogs.push(animal);
      } else if (animal.species === "cat") {
        cats.push(animal);
      }
    });

    // Turn the arrays into JSON strings so they can be written to files
    const dogJSON = JSON.stringify(dogs, null, 2);
    const catJSON = JSON.stringify(cats, null, 2);

    writeFileAsync("dogs.json", dogJSON).then(function() {
      console.log("Successfully wrote to dogs.json file");
    });

    writeFileAsync("cats.json", catJSON).then(function() {
      console.log("Successfully wrote to cats.json file");
    });
  });
  ```

* Demonstrate the following key point(s):

  * üîë Node has a built-in `util` module that has a few useful utility functions.

  * üîë The `util.promisify` method can be used to take a function that uses a Node.js style callback and create a new version of the function that uses Promises. A Node.js style callback is a function that has a `(err, data) =>` signature.

  * üîë We're using the `util.promisify` method to create Promise-based versions of `fs.writeFile` and `fs.readFile`.

* Ask the class the following question(s) and call on students for the corresponding answer(s):

  * ‚òùÔ∏è Do we see any benefit to using Promises over callbacks yet?

  * üôã Not yet?

  * Now that we've had a chance to practice writing basic Promise syntax, we're ready to go over some of the benefits of Promises over callbacks. We'll begin to see this during the review of the next activity.

### 8. Students Do: Joke Saver (10 mins)

* Direct students to the instructions found in [35-Stu-Joke-Saver/README.md](../../../../01-Class-Content/09-NodeJS/01-Activities/35-Stu-Joke-Saver/README.md):

```md
# Joke Saver

In this activity, you will write code to get a random joke from an API, append the joke to a file, and then read out all saved jokes from the file.

## Instructions

* Change directories into the `Unsolved` folder and run `npm install`.

* Once the installation completes, open `Unsolved/index.js` and examine the code.

  * A request is being made to the `icanhazdadjoke` API using axios.

  * This API requires some additional configuration be passed to axios to work.

* Run the `index.js` file to examine the response from the API. You should notice that an object containing a random joke is returned each time.

* Append the `joke` property of the response data to a file named `jokes.txt`.

* After appending the joke, read from the `jokes.txt` file and print its entire contents to the console.

* You can verify you've successfully completed this activity if every time the program is run a new joke is saved to the `jokes.txt` file and all the jokes are printed to the console.

## üí°Hints

* Check out the documentation for [fs.appendFile](https://nodejs.org/api/fs.html#fs_fs_appendfile_path_data_options_callback). Keep in mind that the async version will utilize Promises rather than callbacks.

* Check out the documentation for [fs.readFile](https://nodejs.org/api/fs.html#fs_fs_readfile_path_options_callback). Keep in mind that the async version will utilize Promises rather than callbacks.

## üèÜBonus

* Chain the calls to `axios.get`, `fs.appendFile`, and `fs.readFile` rather than nest them. See more about Promise chaining from the [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises#Chaining).
```

### 9. Instructor Do: Review Joke Saver (5 mins)

Use the prompts and talking points below to demonstrate the following key point(s):

* ‚úîÔ∏è By nesting Promises, we can control the order in which they resolve.

* ‚úîÔ∏è The `util.promisify` method allows us to convert a NodeJS-style callback function to a function that uses Promises instead.

* ‚úîÔ∏è We'll need to use the `fs.appendFile` method to append text to a `txt` file, keeping in mind that each line should be separated by a newline character (`\n`).

* Open the [35-Stu-Joke-Saver/Solved/index.js](../../../../01-Class-Content/09-NodeJS/01-Activities/35-Stu-Joke-Saver/Basic/Solved/index.js) in your editor:

  ```js
  const fs = require("fs");
  const util = require("util");
  const axios = require("axios");

  const appendFileAsync = util.promisify(fs.appendFile);
  const readFileAsync = util.promisify(fs.readFile);

  const config = { headers: { accept: "application/json" } };

  axios
    .get("https://icanhazdadjoke.com/", config)
    .then(function(res) {
      const { joke } = res.data;

      appendFileAsync("jokes.txt", joke + "\n").then(function() {
        readFileAsync("jokes.txt", "utf8").then(function(data) {
          console.log("Saved dad jokes:");
          console.log(data);
        });
      });
    })
    .catch(function(err) {
      console.log(err);
    });
  ```

* Demonstrate the following key point(s):

  * üîë We're using `utils.promisify` to create Promise-based versions of `fs.readFile` and `fs.appendFile`.

  * üîë We're appending the joke retrieved from the API to the `jokes.txt` file with a newline at the end.

  * üîë Inside of the `.then` of the `appendFileAsync` function, we're calling `readFileAsync` to read the file's contents. Since both functions run asynchronously, this is how we can ensure the file isn't read before it's been written to.

* Ask the class the following question(s) and call on students for the corresponding answer(s):

  * ‚òùÔ∏è What are the advantages of using Promises over callbacks in this example?

  * üôã Trick question! There isn't one.

  * So far we still aren't doing anything with Promises that we couldn't do with callbacks alone. One of the advantages of using Promises starts to become clear in the solution to the bonus activity.

* Open [35-Stu-Joke-Saver/Solved/Bonus/index.js](../../../../01-Class-Content/09-NodeJS/01-Activities/35-Stu-Joke-Saver/Solved/Bonus/index.js) in your editor.

  * The functionally of these examples is the same, but there's a key difference in the way the code is written.

  ```js
  axios
    .get("https://icanhazdadjoke.com/", config)
    .then(function(res) {
      const { joke } = res.data;

      return appendFileAsync("jokes.txt", joke + "\n");
    })
    .then(function() {
      return readFileAsync("jokes.txt", "utf8");
    })
    .then(function(data) {
      console.log("Saved dad jokes:");
      console.log(data);
    })
    .catch(function(err) {
      console.log(err);
    });
  ```

* Ask the class the following question(s) and call on students for the corresponding answer(s):

  * ‚òùÔ∏è How is the code in the bonus solution arranged differently than the code in the basic solution?

  * üôã Promises are being chained, rather than being nested inside of each other.

* Highlight the following key point(s):

  * üîë Promises, similar to jQuery methods, are chainable.
  
  * üîë Whatever is returned from the function passed into a Promise's `.then` method is available inside of the next chained Promise.
  
  * üîë If what's being returned is a Promise object itself, the next `.then` only runs when the returned Promise resolves. This is useful as it allows us to write clearer code that's easier to understand and have more control over the sequencing of async behavior.

  * üîë If Promises didn't exist and we only had callback functions, we'd eventually find ourselves in what's referred to as ["callback hell"](http://callbackhell.com/). In "callback hell" our code nesting becomes so deep it's difficult to understand and we have to scroll horizontally in our editors to read everything.

* Slack out the following image to better demonstrate "callback hell":

  ![Callback Hell](https://miro.medium.com/max/3200/1*YCh1fXt_Ycf-00a9E88-Hg.png)

* Answer any remaining questions before the next activity.

### 10. Instructor Do: Introduce the Promise Constructor (10 mins)

* Use the following talking points below:

  * ‚úîÔ∏è Promise objects can be "constructed" from scratch using a JavaScript function

  * ‚úîÔ∏è ES6 introduced native Promises to JavaScript. Before this, Promises were still used, but that functionality was provided by various third party libraries.

  * ‚úîÔ∏è Now that Promises are built-in to JavaScript, we can more easily use Promises to wrap any asynchronous behavior.
  
  * ‚úîÔ∏è The built-in Promise constructor can be used to convert a callback-based function into one using Promises, similar to what `util.promisify` can do for some types of functions.

* Open [36-Ins_Promise-Constructor/index.js](../../../../01-Class-Content/09-NodeJS/01-Activities/36-Ins_Promise-Constructor/index.js) in your editor:

  ```js
  const fs = require("fs");

  function readFileAsync(path, encoding) {
    return new Promise(function(resolve, reject) {
      fs.readFile(path, encoding, function(err, data) {
        if (err) {
          return reject(err);
        }

        resolve(data);
      });
    });
  }

  readFileAsync("example.txt", "utf8")
    .then(function(data) {
      console.log(data);
    })
    .catch(function(err) {
      console.log(err);
    });
  ```

* Highlight the following key point(s):

  * üîë In this example we're using the Promise constructor function to create a `readFileAsync` function, essentially doing what `util.promisify` does for us.

  * üîë `Promise` is a special type of function known as a constructor function. We'll discuss constructor functions in-depth in the next unit, but for now, students just need to understand we call this function using the `new` keyword, and that it returns a new Promise object.

  * üîë The `Promise` function takes one parameter: a callback function. The callback function passed to `Promise` has two parameters of its own: a `resolve` function and a `reject` function.

  * üîë The `resolve` function is called when we're done with our async functionality if nothing went wrong. The `resolve` function can be provided arguments which will be available inside of the `.then` of the resolved Promise.

  * üîë The `reject` function is called if something when wrong, such as an error occurring. Anything provided as an argument to `reject` is available inside of the `.catch` of the rejected Promise.

  * üîë Since `readFileAsync` returns a Promise object, we can execute `readFileAsync` and then use `.then` or `.catch` from its returned value.

* Take a moment to answer any questions before moving on to the next activity.

### 11. Students Do: Promise Constructor (10 mins)

* Direct students to the instructions found in [37-Stu_Promise-Constructor/README.md](../../../../01-Class-Content/09-NodeJS/01-Activities/37-Stu_Promise-Constructor/README.md):

```md
# Promise Constructor

In this activity, you will refactor a callback-based asynchronous function to utilize Promises.

## Instructions

* Open `Unsolved/index.js` and take a moment to examine the provided code.

* When the provided code is run, the `waitFor` function waits `2` (or however many seconds are provided) and then prints a message. If `seconds` is not a number or is a number less than 1, an error is thrown instead.

* Refactor the `waitFor` function to use Promises instead of callbacks.

* You should be able to call the refactored `waitFor` function like so:

  waitFor(2)
    .then(function(msg) {
      console.log(msg); // msg is printed since seconds is more than 0
    })
    .catch(function(err) {
      console.log(err);
    });

  waitFor(-5)
    .then(function(msg) {
      console.log(msg);
    })
    .catch(function(err) {
      console.log(err); // err is printed since 'seconds' is less than 1
    });

## üí° Hints

* Refer back to the previous demo for an example using the Promise constructor.

* Check out the [MDN Documentation on Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
```

### 12. Instructor Do: Review Promise Constructor (5 mins)

* Use the prompts and talking points below to demonstrate the following key point(s):

  * ‚úîÔ∏è When constructing Promise objects, we "resolve" when things go well or we "reject" when they don't.

* Open [37-Stu_Promise-Constructor/Solved/index.js](../../../../01-Class-Content/09-NodeJS/01-Activities/37-Stu_Promise-Constructor/Solved/index.js) in your editor:

  ```js
  function waitFor(seconds) {
    return new Promise(function(resolve, reject) {
      if (isNaN(seconds) || seconds < 1) {
        return reject(Error("Parameter 'seconds' must be a positive number!"));
      }

      setTimeout(function() {
        resolve("Success!");
      }, seconds * 1000);
    });
  }

  waitFor(2)
    .then(function(msg) {
      console.log(msg);
    })
    .catch(function(err) {
      console.log(err);
    });
  ```

* Demonstrate the following key point(s):

  * üîë If `seconds` isn't a number or is a number less than 1, we `reject` an error that will be available in the Promise's `.catch`.

  * üîë When the timeout completes, we call the `resolve` function. Optionally we can pass arguments into `resolve` that will be available in the Promise's `.then`.

  * Understanding how Promises work is far more important than memorizing syntax for constructing them from scratch. Syntax can always be looked up, but this is much harder to do if we don't have a good understanding of what we're trying to achieve.

* Answer any remaining questions before the next activity.

### 13. Instructor Do: Introduce Async/Await (10 mins)

* Use the prompts and talking points below to demonstrate the following key point(s):

  * ‚úîÔ∏è ES2017 introduced an alternative syntax for Promises called async/await.

  * ‚úîÔ∏è Async/await is "sugar-syntax" for Promises, and allows us to write asynchronous code that looks synchronous, which can be easier to understand.

* Ask the class the following questions:

  * ‚òùÔ∏è What do we think is easier? Writing functions with Promises? Or writing functions with callbacks? Which one do we have to know more to use?

  * üôã Promises look nicer than callbacks, but we have to write and understand more code to use them.

  * For many developers, Promises aren't the most intuitive way to handle asynchronous behavior, especially for those coming from other programming languages. As the number of web developers increases, ideas found in other languages often make their way into JavaScript.

  * The ES2017 JavaScript update gave us a feature found in C#: **async/await**.

  * In JavaScript, async/await uses Promises under the hood, but allows us to write asynchronous code in a way that _looks_ synchronous.

  * Async/await is what's called "sugar-syntax". Sugar-syntax is any aspect of the syntax a programming language that makes it easier to read, write, or understand. As an example, the `x += 1` is sugar-syntax for `x = x + 1`.

  * As a result, code written with async/await is often easier to read, write, and understand.

* Open the example in [38-Ins_Async-Await/index.js](../../../../01-Class-Content/09-NodeJS/01-Activities/38-Ins_Async-Await/index.js) in your editor:

  ```js
  const axios = require("axios");
  const inquirer = require("inquirer");

  getMovie();

  async function getMovie() {
    try {
      const { movie } = await inquirer.prompt({
        message: "Search a movie:",
        name: "movie"
      });

      const { data } = await axios.get(
        `https://www.omdbapi.com/?t=${movie}&apikey=trilogy`
      );

      console.log(data);

    } catch (err) {
      console.log(err);
    }
  }
  ```

* Demonstrate the following key point(s):

  * üîë Async/await is used with functions and methods that return Promise objects such as `axios.get` and `inquirer.prompt`.

  * üîë Code using the `await` syntax must be inside of a function declared with the `async` identifier.

  * üîë Using the `await` keyword, we can assign the result of a Promise-based function to a variable.

  * üîë We typically use `try/catch` blocks to catch errors when using async/await, though the `.catch` method can still be used since we're still working with Promises.

* Answer any questions before moving on to the next activity.

### 14. Students Do: Async/Await (15 mins)

* Direct students to the instructions found in [39-Stu_Async-Await/README.md](../../../../01-Class-Content/09-NodeJS/01-Activities/39-Stu_Async-Await/README.md):

```md
# Async Await

In this activity, you will convert a previous Promise-based activity to utilize async await.

## Instructions

* Change directories into the `Unsolved` folder and run `npm install` from your terminal.

* Take a moment to examine the contents of `Unsolved/index.js`. This file:

  * Contains an async function called `combineAnimals` that gets called when the file loads.

  * The `combineAnimals` function contains a try/catch block.
  
  * The goal of this activity is to mirror the functionality found in the previous `37-Stu_Promise-All` activity: animals should be read from each file and then combined into a new `combined.json` file.

* Write code inside of the `try` block to read from each file (`dog.json`, `cat.json`, `goldfish.json`, `hamster.json`) one at a time using the async/await syntax.

* Parse the data from each file to objects using `JSON.parse`.

* Store the animal objects into an array and use `JSON.stringify` to convert the array of objects to a JSON string.

* Save the new combined animal JSON to a `combined.json` file.

* Print a message to the console indicating that this was successful.

## üí°Hints

* Check out the [MDN documentation on async/await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)

## üèÜ Bonus

* Rather than manually writing out code to read each file one at a time, find a way to do so using a loop instead using async/await.

* Sort animals by age before saving them to the `combined.json` file.
```

### 15. Instructor Do: Review Async/Await (10 mins)

* Use the prompts and talking points below to demonstrate the following key point(s):

  * ‚úîÔ∏è Using async/await, we can write asynchronous code that looks synchronous

  * ‚úîÔ∏è async/await is sugar syntax for Promises, meaning Promises are still used under the hood

* Open [39-Stu_Async-Await/Solved/index.js](../../../../01-Class-Content/09-NodeJS/01-Activities/39-Stu_Async-Await/Solved/Basic/index.js) in your editor:

  ```js
  const fs = require("fs");
  const util = require("util");

  const readFileAsync = util.promisify(fs.readFile);
  const writeFileAsync = util.promisify(fs.writeFile);

  async function combineAnimals() {
    try {
      const hamster = await readFileAsync("hamster.json", "utf8");
      const dog = await readFileAsync("dog.json", "utf8");
      const cat = await readFileAsync("cat.json", "utf8");
      const goldfish = await readFileAsync("goldfish.json", "utf8");

      const animalJSON = [hamster, dog, cat, goldfish].map(JSON.parse);

      await writeFileAsync(
        "combined.json",
        JSON.stringify(animalJSON, null, 2),
        "utf8"
      );

      console.log("Successfully wrote to 'combined.json' file");
    } catch (err) {
      console.log(err);
    }
  }

  combineAnimals();
  ```

* Demonstrate the following key point(s):

  * üîë Code using the `await` syntax must be inside of a function declared with the `async` identifier.

  * üîë We can await reading from each file one at a time. This is equivalent to chaining Promise functions in sequence.

  * üîë Since data read from a file comes in as a string, we need to parse the strings to JSON to work with them.

  * üîë `try/catch` blocks are used to handle any errors that may occur.

* Answer any questions about the basic activity before moving on to bonus solution.

* Open [39-Stu_Async-Await/Solved/Bonus/index.js](../../../../01-Class-Content/09-NodeJS/01-Activities/39-Stu_Async-Await/Solved/Bonus/index.js) in your editor:

  ```js
  const fs = require("fs");
  const util = require("util");

  const readFileAsync = util.promisify(fs.readFile);
  const writeFileAsync = util.promisify(fs.writeFile);

  async function combineAnimals() {
    try {
      const animals = [];
      const files = ["dog.json", "goldfish.json", "cat.json", "hamster.json"];

      for (let file of files) {
        const fileStr = await readFileAsync(file, "utf8");

        animals.push(JSON.parse(fileStr));
      }

      const sorted = animals
        .sort(function(a, b) {
          return b.age - a.age;
        });

      await writeFileAsync(
        "combined.json",
        JSON.stringify(sorted, null, 2),
        "utf8"
      );

      console.log("Successfully wrote to 'combined.json' file");
    } catch (err) {
      console.log(err);
    }
  }

  combineAnimals();
  ```

* Demonstrate the following key point(s):

  * üîë When using async/await, we can run asynchronous code inside of a loop and the Promises will be resolved synchronously, i.e. one after the other.

  * üîë We can `await` without storing the value of the resolved Promise in a variable and the next lines of code will still wait to be executed.

* Answer any remaining questions before dismissing the class for the break.

---

### 16. Everyone Do: BREAK (40 mins)

---

### 17. Instructor Do: Introduce Mini Project (5 mins)

* Run the mini-project solution found in [40-Stu_Mini-Project/Solved/Bonus/index.js](../../../../01-Class-Content/09-NodeJS/01-Activities/40-Stu_Mini-Project/Solved/Bonus/index.js) without demonstrating any of the code.

* Answer any questions students may have about the intended functionality of this completed activity.

### 18. Students Do: Mini Project (60 mins)

* Direct students to the instructions found in [40-Stu_Mini-Project](../../../../01-Class-Content/09-NodeJS/01-Activities/40-Stu_Mini-Project/README.md):

```md
# Mini Project

In this activity, you will build a command-line tool that generates and HTML portfolio page from user input.

## Instructions

* Your application should prompt the user for information such as their name, location, bio, LinkedIn URL, and GitHub URL. Feel free to add any additional prompts you think of.

* Using the data collected from the prompts, an HTML document should be constructed containing this information and written to the filesystem. Be sure to add some CSS styling to the document.

* Some tools and technologies you'll need to accomplish this:

  * FS: For writing to the filesystem
  * Inquirer: For collecting user input
  * String template literals: For generating a string version of the HTML document before it is written to the filesystem
  * Promises: For handling asynchronous behavior

## Hint(s)

* It may be a good idea to start building out the HTML skeleton in a real HTML file. Once you're happy with the HTML file's appearance in the browser, you can copy/paste its contents into a string template literal and write a function to insert the user input into the appropriate places in the HTML string before writing it to the filesystem.
```

### 19. Instructor Do: Review Mini Project (10 mins)

* Use the prompts and talking points below to demonstrate the following key point(s):

  * ‚úîÔ∏è We can construct an HTML string using string template literals

  * ‚úîÔ∏è We can use Promises or the async/await syntax to control the flow of asynchronous code

* Open [40-Stu_Mini-Project/Solved/Basic/index.js](../../../../../../../../../../../../01-Class-Content/09-NodeJS/01-Activities/40-Stu_Mini-Project/Solved/Basic/index.js) in your editor:

  ```js
  const inquirer = require("inquirer");
  const fs = require("fs");
  const util = require("util");

  const writeFileAsync = util.promisify(fs.writeFile);

  function promptUser() {
    return inquirer.prompt([
      {
        type: "input",
        name: "name",
        message: "What is your name?"
      },
      {
        type: "input",
        name: "location",
        message: "Where are you from?"
      },
      {
        type: "input",
        name: "hobby",
        message: "What is your favorite hobby?"
      },
      {
        type: "input",
        name: "food",
        message: "What is your favorite food?"
      },
      {
        type: "input",
        name: "github",
        message: "Enter your GitHub Username"
      },
      {
        type: "input",
        name: "linkedin",
        message: "Enter your LinkedIn URL."
      }
    ]);
  }

  function generateHTML(answers) {
    return `
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css">
    <title>Document</title>
  </head>
  <body>
    <div class="jumbotron jumbotron-fluid">
    <div class="container">
      <h1 class="display-4">Hi! My name is ${answers.name}</h1>
      <p class="lead">I am from ${answers.location}.</p>
      <h3>Example heading <span class="badge badge-secondary">Contact Me</span></h3>
      <ul class="list-group">
        <li class="list-group-item">My GitHub username is ${answers.github}</li>
        <li class="list-group-item">LinkedIn: ${answers.linkedin}</li>
      </ul>
    </div>
  </div>
  </body>
  </html>`;
  }

  promptUser()
    .then(function(answers) {
      const html = generateHTML(answers);

      return writeFileAsync("index.html", html);
    })
    .then(function() {
      console.log("Successfully wrote to index.html");
    })
    .catch(function(err) {
      console.log(err);
    });
  ```

* Then, walk through the code and demonstrate the following key point(s):

  * üîë We're chaining the Promises to ensure that a response has been collected from `inquirer.prompt` and the HTML string has been created before writing it to a file.

  * üîë Tagged template literals can be used to construct an HTML string that can then be saved to an HTML file.

* Answer any high-level questions before demonstrating the bonus solution using async/await.

* Open [40-Stu_Mini-Project/Solved/Bonus/index.js](../../../../../../../../../../../../01-Class-Content/09-NodeJS/01-Activities/40-Stu_Mini-Project/Solved/Bonus/index.js)

* Point out the following key point(s):

  * üîë Code using the `await` syntax must be inside of a function declared with the `async` identifier.

  * üîë We're using a `try/catch` block to handle any errors that may occur when using async/await.

* Answer any remaining questions before dismissing the class.

## Lesson Plan Feedback

How did today's class go?

[Went Well](http://www.surveygizmo.com/s3/4325914/FS-Curriculum-Feedback?format=pt&sentiment=positive&lesson=9.03)

[Went Poorly](http://www.surveygizmo.com/s3/4325914/FS-Curriculum-Feedback?format=pt&sentiment=negative&lesson=9.03)
