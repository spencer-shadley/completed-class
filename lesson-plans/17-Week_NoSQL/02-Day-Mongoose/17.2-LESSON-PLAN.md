# 17.2 - Intro To Mongoose

## Instructor Do: Welcome Class and Reintroduce Career Services

- 630-45 (15 min)

- Today we are going to cover mongoose, an ODM

  - type casting, validation, query building, business logic hooks and more out of the box

  - schema - rules for data

  - CRUD with mongoose

  - build relationships between collections

- Now that we are 2/3rds of the way through let's talk about career services

  - talk to Jen with questions

### Ins: 09-Stu-MongoJS-Review

- 645-705 (20 min)

- let's review mongojs

- demo the app

- they will add routes to display and edit book data

### Ins: Review

- 705-15 (10 min)

- notice that we don't need a route for root, instead we are using `express.static`

### Ins: Introduce Mongoose

- (10 min)

- Tell the class that they are now going to be introduced to Mongoose, an Object Data Modeling (ODM) library for Mongo and Node.

  - Mongoose lets you define schemas for your collections.

  - It also helps manage data relationships and enforce validations.

- Next open [10-Ins-Mongoose-Schema] in your IDE and run `npm install` followed by `node server.js`.

- In your terminal you should see the following if the connection was successful.

```js
{ array: [ 'item1', 'item2', 'item3' ],
  _id: 5d445e4e98a11a33f37d6010,
  boolean: false,
  string:
   '"Don\'t worry if it doesn\'t work right. If everything did, you\'d be out of a job" - Mosher\'s Law of Software Engineering',
  number: 42,
  date: 2019-08-02T16:01:18.500Z,
  __v: 0 }
```

- Step through the code that we used to make our db connection and schema.

- We first require the Mongoose package and our `exampleModel` file, which contains our schema.

  ```js
  const mongoose = require('mongoose');
  const Example = require('./exampleModel.js'); // we will go over this file next as it contains our schema
  ```

- We then open a connection `mongodb://localhost/dbExample` on our locally running instance of MongoDB.

  ```js
  mongoose.connect('mongodb://localhost/dbExample', { useNewUrlParser: true });
  ```

- Then we create some data to insert into our database.

  ```js
  const data = {
    array: ['item1', 'item2', 'item3'],
    boolean: false,
    string: 'We are learning mongoose!',
    number: 42
  };
  ```

- Next we call `create` on our `Example` schema and pass in our data.

  ```js
  Example.create(data)
    .then(dbExample => {
      console.log(dbExample);
    })
    .catch(({ message }) => {
      console.log(message);
    });
  ```

- Now open [10-Ins-Mongoose-Schema] in your editor.

- Tell the class that Mongoose models are similar to those in sequelize.

- We define a schema for the model and then use the model to query our database.

- Next, step through each section of the code.

- First we import mongoose and create a `Schema` reference.

  ```js
  const mongoose = require('mongoose');
  const Schema = mongoose.Schema;
  ```

- Next we create a new schema called `ExampleSchema`.

  ```js
  const ExampleSchema = new Schema({
    string: {
      type: String,
      trim: true,
      required: 'String is Required' // validator
    },

    number: {
      type: Number,
      unique: true, // this is not a validator, but a built in helper
      required: true // validator
    },

    email: {
      type: String,
      match: [/.+@.+\..+/, 'Please enter a valid e-mail address']
    },

    boolean: Boolean,

    array: Array,

    date: {
      type: Date,
      default: Date.now
    },

    longstring: {
      type: String,
      validate: [({ length }) => length >= 6, 'Longstring should be longer.']
    }
  });
  ```

- We then compile our schema into a Model.

  ```js
  const Example = mongoose.model('Example', ExampleSchema);
  export default Example;
  ```

- Tell the class that all schema types have the built-in `required` validator.

- Point out that numbers have `min` and `max` validators while strings have `enum`, `match`, `minlength`, and `maxlength` validators.

- Ask the students the following question(s):

  - What are the benefits of using Mongoose?

  - It let's use create a schema, enforce validations and overall make it easier to interface with a Mongoose database.

### Ins: Demo Solved Mongoose Schema

- (5 min)

- Open [11-Stu-Mongoose-Schema/Solved] on your machine and run `npm install` then `node server.js` to launch the app.

- Create a new user and demonstrate the response.

  ```js
  {
    "_id": "5cfab6403da88328fcc7ac39",
    "username": "demo",
    "password": "demo",
    "email": "demo@gmail.com",
    "userCreated": "2019-06-07T19:08:48.294Z",
    "__v": 0
  }
  ```

- Try to create another user with the same email to demonstrate the validations.

  ```js
  {
    "driver": true,
    "name": "MongoError",
    "index": 0,
    "code": 11000,
    "errmsg": "E11000 duplicate key error collection: userdb.users index: email_1 dup key:  {: \"demo@gmail.com\" }"
  }
  ```

- Tell the students that in the next activity they will implement the schema validations that they see here.

### Stu: Mongoose Schema

- (15 min)

- Direct students towards the next activity located in [11-Stu-Mongoose-Schema/Unsolved].

```md
# User Schema

In this activity you will create a user schema with mongoose.

## Instructions

- In `userModel.js` add four attributes to your schema.

  - username: A string that will be be required, and also trimmed.

  - password: A string that will be required, trimmed, and at least 6 characters.

  - email: A string that must be a valid email address and unique in our collection.

  - userCreated: A date that will default to the current date.

## Hint(s)

- The regex for checking if a string is an email is: /.+\@.+\..+/

## Bonus

- Insert five more documents with one command. Use [https://docs.mongodb.com/manual/tutorial/query-documents/](https://docs.mongodb.com/manual/tutorial/query-documents/) to see how you can accomplish this.
```

### Ins: Review

- (10 min)

  - We can use `required` to check for the presence of an attribute.

- We can use `validate` to enforce a validation.

- Open [11-Stu-Mongoose-Schema/Solved] in your IDE and step through each attribute, checking for understanding.

```js
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const UserSchema = new Schema({
  username: {
    type: String,
    trim: true,
    required: 'Username is Required'
  },

  password: {
    type: String,
    trim: true,
    required: 'Password is Required',
    validate: [({ length }) => length >= 6, 'Password should be longer.']
  },

  email: {
    type: String,
    unique: true,
    match: [/.+@.+\..+/, 'Please enter a valid e-mail address']
  },

  userCreated: {
    type: Date,
    default: Date.now
  }
});
```

- Students may be confused with `match`, explain that it uses a regular expression to check for a valid email address.

- Ask the students the following question(s):

  - What is the `match` method checking for in our `email` attribute?

  - It is checking the regular expression against the user's email input.

### BREAK

- (15 min)

### Ins: Custom Methods

- (10 min)

  - Mongoose provides a way for us to create custom methods to manipulate our data.

- Change into [12-Ins-Custom-Methods] and run `npm install` then `node server.js` to launch the app.

- Visit `localhost:3000` and fill out the form to create a new user and demo the response.

  ```js
  {
    "isCool": true,
    "_id": "5cfbbd607de1a557eeaaa056",
    "username": "test...the Coolest!",
    "password": "password1234",
    "email": "testuser@gmail.com",
    "userCreated": "2019-06-08T13:51:28.033Z",
    "__v": 0
  }
  ```

- Ask the students the following question(s):

  - What is difference about the way our data was returned?

  - Our new user has an `isCool` field that is set to `true`.

- Open [12-Ins-Custom-Methods/userModel.js] and scroll down to the custom methods.

- Here

  ```js
  UserSchema.methods.coolifier = function() {
    this.username = `${this.username}...the Coolest!`;
    return this.username;
  };

  UserSchema.methods.makeCool = function() {
    this.isCool = true;
    return this.isCool;
  };
  ```

- Next open `server.js` and demonstrate how we are calling our methods on our new user.

  ```js
  app.post('/submit', ({ body }, res) => {
    const user = new User(body);
    user.coolifier(); // Bob...the Coolest!
    user.makeCool(); // isCool = true;

    User.create(user)
      .then(dbUser => {
        res.json(dbUser);
      })
      .catch(err => {
        res.json(err);
      });
  });
  ```

- Ask the students the following question(s):

  - What are the benefits of using Mongoose?

  - It let's use create a schema, enforce validations and overall make it easier to interface with a Mongoose database.

### Stu: Custom Methods

- (15 min)

- Direct students to the next activity located in [13-Stu-Custom-Methods/Unsolved]

- # Instructions

- Open `userModel.js` and create the following custom methods.

  - `setFullName`: sets the current user's `fullName` property to their lastName appended to their `firstName`

  - `lastUpdatedDate`: sets the current user's `lastUpdated` property to `Date.now()`

- When you are finished use your new custom methods in a `POST` request.

### Ins: Review

- (10 min)

- Change into [13-Stu-Custom-Methods/Solved] and open the `userModel.js` file.

- Ask for a volunteer to lead your through the custom methods they created.

- Next open `server.js` and ask for a volunteer to explain how to call these new methods in that file.

- Start the server and load up the site in your browser to demonstrate the form.

### Ins: Mongoose Populate

- (10 min)

- Change into [14-Ins-Populate] and start the server with `node server.js`.

- Then, visit `/books` to see your books listed.

```js
[
  {
    _id: '5cfbc820bc851f678c714b2c',
    author: 'Herman Melville',
    title: 'Moby Dick',
    __v: 0
  },
  {
    _id: '5cfbc83ebc851f678c714b2d',
    author: 'F. Scott Fitzgerald',
    title: 'The Great Gatsby',
    __v: 0
  }
];
```

- Then visit `/library` to see your library data listed in JSON, including a list of `ObjectIds` in the book property. These are the `ObjectIds` associated with each book we've made.

```js
[
  {
    books: [
      '5cfbc510fff60b62b1a9c318',
      '5cfbc51cfff60b62b1a9c319',
      '5cfbc820bc851f678c714b2c',
      '5cfbc83ebc851f678c714b2d'
    ],
    _id: '5cfbc29cfff60b62b1a9c317',
    name: 'Campus Library',
    __v: 0
  }
];
```

- Ask students, what if we want to see the data for all of the books stored in our library. We could go back to books, but what if we want to include all of the information about our library and our books, and query that data with just one call.

  - Answer: This is where `Mongoose`'s populate method comes in. Open the `/populated` route in your browser, and go to the books property. All of the books will be there.

  ```js
  [
    {
      books: [
        {
          _id: '5cfbc820bc851f678c714b2c',
          author: 'Herman Melville',
          title: 'Moby Dick',
          __v: 0
        },
        {
          _id: '5cfbc83ebc851f678c714b2d',
          author: 'F. Scott Fitzgerald',
          title: 'The Great Gatsby',
          __v: 0
        }
      ],
      _id: '5cfbc29cfff60b62b1a9c317',
      name: 'Campus Library',
      __v: 0
    }
  ];
  ```

- How does this happen?

  - Show them the `Library.js` model, and how it has a reference to the `Book.js` model inside it's schema.

    ```js
    const mongoose = require('mongoose');

    const Schema = mongoose.Schema;

    const LibrarySchema = new Schema({
      name: {
        type: String,
        unique: true
      },
      books: [
        {
          type: Schema.Types.ObjectId,
          ref: 'Book'
        }
      ]
    });

    const Library = mongoose.model('Library', LibrarySchema);

    module.exports = Library;
    ```

  - Then show them the `index.js` file inside of the `models` folder.

    ```js
    module.exports = {
      Book: require('./Book'),
      Library: require('./Library')
    };
    ```

  - Explain that when working with multiple models, it's often useful to be able to require all of them at once, rather than individually.

  - By exporting an object containing all of our models from the `index.js` file in the models folder, we can then require this object and access all of our models inside of `server.js`.

    ```js
    const db = require('./models');
    ```

  - Point out the `populate` method being used in `server.js`.

    ```js
    app.get('/populated', (req, res) => {
      db.Library.find({})
        .populate('books')
        .then(dbLibrary => {
          res.json(dbLibrary);
        })
        .catch(err => {
          res.json(err);
        });
    });
    ```

  - Explain that here we are running `populate("books")` after finding books and before handling the result of the query in `.then`.

### Stu: Mongoose Populate

- (20 min)

- Direct students towards the next activity located in [15-Stu-Populate/Unsolved]

# Instructions

- Open `server.js` and update the `/populate` route to return `Users` populated with notes as JSON to the client.

- **Hint:** Check out the `Note.js` and `User.js` models to see how the schemas there make the populate method possible.

### Ins: Review

- (15 min)

- Open up [15-Stu-Populate/Solved/server.js].

- Ask for a volunteer to to walk you through the solution.

```js
app.get('/populateduser', (req, res) => {
  db.User.find({})
    .populate('notes')
    .then(dbUser => {
      res.json(dbUser);
    })
    .catch(err => {
      res.json(err);
    });
});
```

- Answer any clarifying questions about this activity or any other concepts covered today before wrapping up.
