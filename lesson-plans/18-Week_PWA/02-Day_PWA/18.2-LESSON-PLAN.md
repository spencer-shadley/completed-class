# 18.2 - Progressive Web Applications

### Ins: Progressive Web Apps

- 630-40 (10 min)

- We will add a web app manifest and service worker to a gallery app to have a complete PWA with offline capabilities

- Explain PWA - sort of like an installable website. It is a generalization for websites that meet certain criteria around being able to perform like a native app. Once this criteria is met it is considered a PWA.

  - It is still built as a website but can be "installed" as an app that looks "native" (written for a specific platform)

  - Adds installation, push notifications, splash screen, offline

- Show [PWA checklist](https://web.dev/pwa-checklist/)

- Demo installing Google Maps PWA

- Demo installing the images app as a PWA

### Stu: 07-Stu_PWAs

- 640-55 (15 min)

### Ins: Review and 08-Ins_Manifest

- 7-10 (10 min)

- PWAs require a manifest, a service worker and the Cache API

- write one PWA to be delivered as website, desktop app, Android app and iOS app

- to setup our PWAs we need:

  - An app manifest (metadata about the site such as primary color and icon)

  - A service worker to handle the flow of installation, enable offline usage and support push notifications

  - Cache API

- Demo "Application" tab for https://secure-bayou-27137.herokuapp.com/

  - Cache Storage (cached assets)

  - Service Workers

    - Check "Offline" and reload (make sure network does not disable cache)

  - Manifest

- manifest - demo 08-Ins_Manifest

  - JSON

  - properties are called members

  - `short_name`: Optional for restrictive text locations such as an app launcher

  - `name`: Primary name to be displayed to user (installation for example)

  - `icons`: array of icons to be shown (launcher, task switcher, etc.)

  - `start_url`: when launched, where should it start

  - `display`: preferred mode (fullscreen, standalone, minimal-ui or browser)

  - `background_color`: placeholder background before stylesheet loads

  - `theme_color`: used for places like the chrome in the Android Chrome browser, can color various OS elements like Android's task switcher

- `manifest.webmanifest` is JSON file providing information for mobile and desktop installation

### Stu: 09-Stu_Manifest

- 710-25 (15 min)

### Ins: Review

- 725-35 (10 min)

- go through each member in the manifest

- show `index.html` which links it in

### Ins: 10-Ins_Service_Workers

- 735-45 (10 min)

- start with [overview](18-pwa\supplemental\service-workers.md)

- `public/index.html`

- `public/service-worker.js`

  - the log does occur

### Stu: 11-Stu_Service_Workers

- 740-55 (10 min)

### Ins: Review

- 755-810 (15 min)

  - We are adding an event listener to our window element, listening for the `load` event.

  - We register our service worker using the `navigator` object.

  - We console.log a message letting us know that the service worker registration was successful.

```js
<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('service-worker.js')
        .then((reg) => {
          console.log('We found your service worker file!', reg);
        });
    });
  }
</script>
```

- What step of the service worker lifecycle have we just completed?

- The registration step.

### BREAK

- 810-25 (15 min)

### Ins: 12-Ins_Caching_Fetching_Files

- 825-30 (5 min)

- All files that need to be cached are stored as strings in an array.

- All files that need to be cached are precached in the `install` step.

- The `activate` step clears out the all outdated caches.

- The `fetch` listener intercepts all fetch requests and uses data from the cache to return a response.

  - If we inspect our Sources with DevTools, we can see that our service worker is running on a separate thread.

- `service-worker.js`

  - Now that we have successfully registered our service worker, we'll step through the code that will install and activate it. This will give our service worker the ability to cache the files we tell it to and deliver them in an offline experience for our users.

  - Our `FILES_TO_CACHE` variable keeps track of each file that we want to store in our cache.

  - This is an array of _files_ only, attempting to include entire directorys won't work.

  The `ALL_CAPS_SEPARATED_BY_UNDERSCORES` style is just standard convention for the global variables in our service worker.

  ```js
  const FILES_TO_CACHE = [
    "/",
    "/index.html",
    "/assets/css/style.css",
    "/assets/js/loadPosts.js",
    "/assets/images/Angular-icon.png",
    "/assets/images/React-icon.png",
    "/assets/images/Vue.js-icon.png",
    "/manifest.webmanifest",
    ...
    ...
  ];

  // set cache variable names
  const CACHE_NAME = 'static-cache-v2';
  const DATA_CACHE_NAME = 'data-cache-v1';
  ```

  - Inside our install event listener callback we open our cache and call `addAll`, passing in `FILES_TO_CACHE`.

  ```js
  // install
  self.addEventListener('install', function(evt) {
    evt.waitUntil(
      caches.open(CACHE_NAME).then(cache => {
        console.log('Your files were pre-cached successfully!');
        return cache.addAll(FILES_TO_CACHE);
      })
    );

    // skipWaiting() ensures that any new versions of our service worker will take over the page and become activated immediately
    self.skipWaiting();
  });
  ```

  - Inside the activate event listener callback, we activate our service worker, cleaning up outdated caches.

  ```js
  // activate
  self.addEventListener('activate', function(evt) {
    evt.waitUntil(
      caches.keys().then(keyList => {
        return Promise.all(
          keyList.map(key => {
            if (key !== CACHE_NAME && key !== DATA_CACHE_NAME) {
              console.log('Removing old cache data', key);
              return caches.delete(key);
            }
          })
        );
      })
    );

    // Tells our new service worker to take over.
    self.clients.claim();
  });
  ```

  - Here we modify the service worker to handle requests to `/api` and store the responses in our cache, so we can easily access them later.

  ```js
  // fetch
  self.addEventListener('fetch', function(evt) {
    if (evt.request.url.includes('/api/')) {
      console.log('[Service Worker] Fetch (data)', evt.request.url);

      evt.respondWith(
        caches.open(DATA_CACHE_NAME).then(cache => {
          return fetch(evt.request)
            .then(response => {
              // If the response was good, clone it and store it in the cache.
              if (response.status === 200) {
                cache.put(evt.request.url, response.clone());
              }

              return response;
            })
  ```

  - If the network request fails, we try to get the response from our cache.

  ```js
    .catch(err => {
      return cache.match(evt.request);
    });
  ```

- `loadPosts.js`

  - We are going to skip past the DOM element creation and focus on the handling of our "like" POST request.

  - When a user likes a post, we increment it's `data-likes` attribute by 1.

  ```js
  function incrementLikes(event) {
    const statusEl = document.querySelector("#status")

    const id = event.currentTarget.getAttribute("id");
    const oldLikes = parseFloat(event.currentTarget.getAttribute("data-likes"));
    const likes = oldLikes + 1;

    event.currentTarget.setAttribute("data-likes", likes);

    statusEl.innerText = "";
  ```

  - `incrementLikesRequest` makes an API call, then sets a status DOM element at the top of the page to let the user know whether of not their save was successful.

  ```js
  incrementLikesRequest(id, likes)
    .then(() => {
      statusEl.innerText = 'Save successful!';
      updateLikesDisplay(id, likes, true);
    })
    .catch(() => {
      statusEl.innerText =
        "Sorry, your 'like' cannot be recorded while you are offline.";
      updateLikesDisplay(id, likes, false);
    });
  ```

  - In `updateLikesDisplay` we indicate to the user whether or not their likes count is up to date by appending `(not saved)` to the like count for each post.

  ```js
  function updateLikesDisplay(id, likes, saved) {
    const likesCount = document.querySelector(`#likes-count-${id}`);
    likesCount.innerText = `Likes: ${likes}`;
    if (!saved) {
      likesCount.innerText += ' (not saved)';
    }
  }
  ```

- There is quite a bit of code here so take the time to step through it, clarifying any questions as you go.

  - Our service worker is caching all of the files we tell it to so when a user doesn't have a connection, it can deliver them an offline browsing experience. If a user is offline, we must make sure that they can still use the application as much as possible, even if this means letting them know their data won't be saved until later.

  - What kind of events do we have to listen for in our service worker file?

  - Install and activate. We also listen for `fetch` if our application interacts with an API.

### Stu: 13-Stu_Caching_Fetching_Files

- 830-40 (10 min)

### Ins: Review

- 840-45 (5 min)

- `service-worker.js`

  - First we set up the files that we need to cache.

  ```js
  const FILES_TO_CACHE = [
    '/',
    '/offline.html',
    '/index.html',
    '/assets/css/style.css',
    '/assets/js/app.js',
    '/assets/js/loadImages.js',
    '/assets/js/install.js',
    '/assets/images/1.jpg',
    '/assets/images/2.jpg',
    ...
    ...
  ];

  const CACHE_NAME = 'static-cache-v2';
  const DATA_CACHE_NAME = 'data-cache-v1';
  ```

- Then, we install and register our service worker.

  ```js
  self.addEventListener('install', function(evt) {
    evt.waitUntil(
      caches.open(CACHE_NAME).then(cache => {
        console.log('Your files were pre-cached successfully!');
        return cache.addAll(FILES_TO_CACHE);
      })
    );

    self.skipWaiting();
  });
  ```

  - If done successfully, we should see our static cache in our Application tab.

    - Next we activate our service worker.

  ```js
  self.addEventListener('activate', function(evt) {
    evt.waitUntil(
      caches.keys().then(keyList => {
        return Promise.all(
          keyList.map(key => {
            if (key !== CACHE_NAME && key !== DATA_CACHE_NAME) {
              console.log('Removing old cache data', key);
              return caches.delete(key);
            }
          })
        );
      })
    );

    self.clients.claim();
  });
  ```

  - Lastly, we handle all fetching for any request with a url that includes `/api/`.

  - If the response is successful, we clone it and store it in our cache.

  - If the network request fails, we grab it from our cache.

  ```js
  self.addEventListener('fetch', function(evt) {
    if (evt.request.url.includes('/api/')) {
      evt.respondWith(
        caches.open(DATA_CACHE_NAME).then(cache => {
          return fetch(evt.request)
            .then(response => {
              if (response.status === 200) {
                cache.put(evt.request.url, response.clone());
              }

              return response;
            })
            .catch(err => {
              return cache.match(evt.request);
            });
        })
      );

      return;
    }

    evt.respondWith(
      caches.open(CACHE_NAME).then(cache => {
        return cache.match(evt.request).then(response => {
          return response || fetch(evt.request);
        });
      })
    );
  });
  ```

  - If done successfully we will see your data cache in your Application tab. At this point we should be able to put our application in offline mode for an offline experience.

  - What does a service worker do?

  - A service worker acts as an intermediate step in between an API call and the browser. It can cache files and help provide an offline experience.

  - When using a service worker, can we send POST requests to an API while offline?

  - No, POST/PUT requests must be handled separately. If we wish to "cache" the POST data, we can store it in IndexedDb.

  - How many times does the install event run for each service worker?

  - Once.

  - What does `self.skipWaiting()` do?

  - `self.skipWaiting()` forces the service worker to activate as soon as it's finished installing.

### Ins: 14-Stu_Notetaker_PWA

- 845-50 (5 min)

- First let's make sure our app works as expected by adding a note normally.

- Next, we'll open up the Chrome Developer Tools and navigate to the `Service Worker` tab. Here, let's toggle the offline version and refresh the app.

  - Just like our other two apps, all of our resources have been cached and do not require a connection to access.

### Stu: 14-Stu_Notetaker_PWA

- 850-920 (30 min)

### Ins: Review

- 920-35 (15 min)

- `manifest.webmanifest`

  - Our manifest includes a name, `short_name`, several icons, and theme colors for our PWA

- `service-worker.js`

  - The only files we need to cache are `index.html`, `app.js`, and our favicon.

  - Our caches will be named `static-cache-v2` and `data-cache-v1` respectively.

  ```js
  const FILES_TO_CACHE = ['/', '/index.html', 'app.js', 'favicon.ico'];

  const CACHE_NAME = 'static-cache-v2';
  const DATA_CACHE_NAME = 'data-cache-v1';
  ```

- When install is triggered, we will add all of our specified files to the cache.

  ```js
  // install
  self.addEventListener('install', function(evt) {
    evt.waitUntil(
      caches.open(CACHE_NAME).then(cache => {
        console.log('Your files were pre-cached successfully!');
        return cache.addAll(FILES_TO_CACHE);
      })
    );

    self.skipWaiting();
  });
  ```

- The activate event fires when an old service worker is gone and the new one is installed. We use this listener to get rid of our old cache.

```js
self.addEventListener('activate', function(evt) {
  evt.waitUntil(
    caches.keys().then(keyList => {
      return Promise.all(
        keyList.map(key => {
          if (key !== CACHE_NAME && key !== DATA_CACHE_NAME) {
            console.log('Removing old cache data', key);
            return caches.delete(key);
          }
        })
      );
    })
  );
  self.clients.claim();
});
```

- Our `fetch` call has changed, since we are only fetching our cached static resources.

```js
// fetch
self.addEventListener('fetch', function(evt) {
  evt.respondWith(
    caches.open(CACHE_NAME).then(cache => {
      return cache.match(evt.request).then(response => {
        return response || fetch(evt.request);
      });
    })
  );
});
```
