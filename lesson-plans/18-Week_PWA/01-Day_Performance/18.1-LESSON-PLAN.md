# 18.1 - Web Performance

### Ins: Welcome/Intro Web Performance

- 630-40 (10 min)

- We're going to focus on web performance

  - Lighthouse auditing

  - Minification

  - Compression

  - lazy loading

- we're going to use project 2 for these tests

- ask for someone's favorite website

  - load it in Slow 3G with the network tab open (disable cache too)

    - explain throttling

  - hover on one of the bars to get color legend

  - lots of stuff is just waiting because browsers only support about 6 concurrent connections to handle requests

    - could improve by having fewer requests

  - lots of stuff takes a long time to download

    - could improve by making stuff smaller

- A study by Strangeloop, a web acceleration company that performed various surveys, which Tableau is using to inform our product decisions found the following:

  - 78% of users felt stress or anger when using a slow website

  - 47% of users expect a web page to load in 2 seconds or less

  - A 1 second delay results in a 16% decrease in satisfaction

  - A single bad experience caused about half o f users to express a less positive perception of the company overall

  - user behavior changed with delays as small as 100ms (time to blink your eyes)

    - likely a subconscious reaction

    - issued fewer queries, less likely to click links and waited longer to engage with the page

    - after improving performance Google found it took some users six weeks to return to their baseline behavior (this means if your site performs poorly within six weeks you get suboptimal behavior and perception)

  - iconic (visual) memory lasts about 100ms, the same as above

    - when clicking a button our brain expects to see the button change to its pressed state in our iconic memory (100ms)

    - short term meory lasts 10-15s

  - strangeloop found that users have to concentrate up to 50% harder when using a slow site

  | Time Spent | Interaction Class | Notes                                                          |
  | ---------- | ----------------- | -------------------------------------------------------------- |
  | < 100ms    | Instantaneous     | Software objects that mimic physical objects (ex. Buttons)     |
  | < 1s       | Immediate         | Signal or acknowledgement that a command has been received     |
  | 2-5s       | Flow              | Does not break user's concentration                            |
  | 7-10s      | Captive           | User is likely to switch to something else and come back later |

### Ins: Demo Lighthouse

- 640-50 (10 min)

- Demo 05-Stu_Gallery-Lazy-Load

  - Google has created a tool called Lighthouse which will allow us to run an audit on our page and find out different metrics about how it performs and what is hindering its performance. Lighthouse is a quality auditing tool developed by Google for analyzing web pages.

  - It provides audits for performance, accessibility, SEO, and progressive web applications.

  - Lighthouse can be run directly from our Chrome Dev Tools. This makes it a fast, simple, and effective way to get insights into our pages overall performance metrics.

  - Open chrome dev tools, and click the `Audits` tab.

  - Scroll down and click `Run Audits`

    - Performance - what we're focusing on today

    - Accessibility - can a blind person use your site? Someone with color blindness?

    - Best Practices - various standards are checked for

    - SEO

    - PWA

    - Contentful paint: any content is loaded - first time text or image is shown

    - Meaningful paint: primary content is shown

    - Time to interactive: webpage becomes usable

- Ask: what can lighthouse help with?

  - Identifying places to optimize

- Ask: when should we run it?

  - frequently

### Stu: 01-Stu_Lighthouse

- 650-658 (8 min)

- Run lighthouse on project 2

### Ins: Review

- 658-703 (5 min)

- Ask:

  - What are some of the 'Opportunities' for improvement you found in your applications?

  - How long did the first content paint take?

  - How long did the first meaningful paint take?

  - How long did it take to become interactive?

- Are there any commonalities you hear?

### Ins: JS Minification

- 703-13 (10 min)

- Ask: What is minification?

  - Removing unnecessary things like whitespace and making variable names smaller

  - [jquery source](https://code.jquery.com/jquery-3.4.1.js)

    - if printed it would take 170 pages

    - 274KB

  - [jquery minfied](https://code.jquery.com/jquery-3.4.1.min.js)

    - if printed it would take 17 pages

    - 87KB

- Open [JavaScript Minifier](https://javascript-minifier.com/) and paste the following code into the textarea:

  ```js
  const myArray = [1, 2, 3, 4, 5];

  for (let increment = 0; increment < myArray.length; ++increment) {
    console.log(myArray[increment]);
  }
  ```

  - 145 characters => 83 characters (43% smaller)

- Ask the class, "What are the benefits of minification?"

- When would we want a file to be minified? Do we even still want the non-minified version?

  - We probably want both, non-minified for developing and minified and for production

  - we store minified files in a directory called `dist`, generally (distribution)

### Stu: Minify your JavaScript

- 713-23 (10 min)

- Direct students to the activity instructions located in [02-Stu_Minifiy-JS]

### Ins: Review

- 723-28 (5 min)

- Ask: Who got at least 10%, 20%, etc.

### Ins: Compression npm package

- 728-38 (10 min)

- This is JavaScript but images tend to be much larger. Can we minify them too?

- Ask the class, "What is a zip file?"

  - A `.zip` file is a compressed version of a normal directory. When you `unzip` it, the directory contains all of the information it had before it was zipped.

    - we're going to do this on the web to save on payload

    - but we're going to `gzip`, an alternative for comrpessing/decompressing files which is standard for unix, linux and mac

    - HTTP supports decompressing gzip directly

- we're going to use an npm middleware package to compress things like images

  - https://www.npmjs.com/package/compression

- it will take three lines of code to compress everything

- Open up your `network` tab in the chrome dev tools. Navigate to the [New York Times](https://www.nytimes.com/).

- Point students to all the incoming network traffic shown, and more specifically the file sizes column.

- There is a file size showing the compressed size (Smaller number) and its uncompressed size (larger number).

  - Files that don't have two numbers are uncompressed files being sent unchanged.

### Stu: Enable Compression

- (10 min)

- Direct students to the activity instructions located [03-Stu_Enable-Compression]

### Ins: Review

- (5 min)

- Open [03-Stu_Enable-Compression](../../../../01-Class-Content/18-PWA/01-Activities/03-Stu_Enable-Compression/Solved) in your IDE and explain the following points

  - We first `npm install compression`

  - We then add the following code to our `server.js`:

  ```js
  const express = require('express');
  const mongoose = require('mongoose');
  const compression = require('compression');

  const app = express();

  app.use(compression());
  ```

### BREAK

- (15 min)

### Ins: Introduce Image Compression

- (5 min)

- Have you ever gone to a site and experienced slow image loading times?

  - Images are one of the most used assets on the web. They are everywhere, and there are more than you can imagine.

  - This is normally due to oversized images or high resolution images being downloaded and taking time. Images are one of the main culprits in slowing down web loading times.

- How might we be able to fix the problem of images that are too large?

  - We can use a concept called _Image Compression_. For the purposes of our course we are going to talk about _Lossy Image Compression_.

- What do we mean by "lossy" image compression?

  - What lossy image compression basically means is that some of the image data is lost during compression. Once an image has used lossy compression, you cannot reverse the process due to this loss of data. The data lost will normally result in almost unnoticeable changes in image quality most of the time.

### Stu: 04-Stu_Image-Compression

- (10 min)

### Ins: Review

- (5 min)

- Did you see a loss in image quality?

  - Image compression allows us to lower load times for our users without a loss of visual fidelity.

- Do you see the benefits of compressing images?

  - When we can save space while maintaining visual quality, that is a win win. It allows for us to have high resolution images for our page while we are still decreasing download/load times for our user.

- What are some other things we can do to decrease our load times?

  - We can load only images that are present on the screen. If the image is not visible to the user, we shouldn't bother downloading it yet.

- Ask the class, "What if a user doesn't scroll through all of the images?"

  - Now that we have compressed all of our images, we are certainly saving space. Point out, we are loading all 38 images when there is only 6-9 images showing at any time. If a students user is on mobile, it would only be 1-2 images at any time.

  - This poses multiple problems. It not only makes loading slower, but is costly when it comes to data and those people using mobile who may not have an unlimited data plan. We certainly don't want to cost our user time and money, so what can be done?

- Ask the class, "Why do we load all of the images at page load, if the user might not see them all?"

  - Loading everything at once is the default. There is a concept in programming referred to as `lazy loading` that allows us to only download assets as they are needed.

- Use students answers to transition to the next activity.

### Ins: Lazy Loading

- (10 min)

- Open our completed [Lazy Loading Gallery App](https://ancient-brushlands-76706.herokuapp.com/) and demo the lazy loading functionality by scrolling to the bottom of the page.

  - If it loads too quickly, open your `Network` tab in your Dev Tools and throttle to `slow 3g`, disable cache, and refresh the page.

- Ask the class, "What would enable us to know when an image is coming into the users viewport?"

  - A Web API based on `scroll` events and the viewport intersection would allow us to keep an eye on when an element is or is not in view of our user.

  - In the case of this application, we are loading 38 images when we may not need them all. Using lazy loading, If images were scrolled onto the screen that event would then load the images if they had entered the viewport.

- Ask the class, "What web API would allow us this functionality?

  - The `Intersection Observer API`. It provides a way to asynchronously observe when an element is or is not within our users viewport.

  - We can use this API to watch and then target elements as they enter the viewport

- Ask the class, "How can the Intersection Observer API help us with loading images?"

  - We are able to target images we would like, and observe them. As they enter the viewport of our user we can trigger a function that will then and only then load the image that has entered the viewport.

  - Let's look at a code snippet that enables image lazy loading via JavaScript.

- Walk through the comments below:

```js
function initLazyImages() {
  // Gather all of our images into a variable
  const lazyImages = document.querySelectorAll('.lazy-image');

  function onIntersection(imageEntities) {
    imageEntities.forEach(image => {
      // When the image begins to intersect viewport, execute the if code block
      if (image.isIntersecting) {
        // Now that it is in viewport, we do not need to observe it anymore.
        observer.unobserve(image.target);
        // Set the image src to the image that has entered viewport.
        image.target.src = image.target.dataset.src;
      }
    });
  }
  // Create a new instance of Intersection Observer
  const observer = new IntersectionObserver(onIntersection);
  // Observe all images on load.
  lazyImages.forEach(image => observer.observe(image));
}
```

- Ask the class, "How does this benefit our user?"

  - By loading only necessary images, we can cut download/load times consistently and ensure as fast an experience as possible.

- Use student answers to transition to the next activity.

### Stu: 05-Stu_Gallery-Lazy-Load

- (15 min)

### Ins: Review

- (5 min)

- Open the [solved Gallery Lazy Loading app](../../../../01-Class-Content/18-web-performance/01-Activities/05-Stu_Gallery-Lazy-Load/Solved/).

- Walk students through the code that enables lazy loading in our application.

```js
function initLazyImages() {
  const lazyImages = document.querySelectorAll(".lazy-image");
```

- First we create a `const` called `lazyImages`. We save all elements with the class `lazy-image` to this constant variable

```js
function onIntersection(imageEntities) {
  imageEntities.forEach(image => {
    if (image.isIntersecting) {
      observer.unobserve(image.target);
      image.target.src = image.target.dataset.src;
    }
  });
}
```

- Next, we create an `onIntersection` function. In this function we state that for each mage, if the image is intersecting the viewport we load our image and stop observing it as it is now on screen.

```js
const observer = new IntersectionObserver(onIntersection);
```

- We used a constructor function to create a new instance of IntersectionObserver, saving it to a constant variable `observer`. This allowed us to use it in our `onIntersection` function.

```js
  lazyImages.forEach(image => observer.observe(image));
}
```

- The final line subscribes all images to be observed by IntersectionObserver to it can download the proper image when the placeholder is scrolled into view.

### Ins: Intro Gallery App Full Optimization

- (5 min)

- Let students know they did a great job today. Web performance is important, and they now have a foundation to learn more and become great at optimizing applications.

- For the final activity of the day students wil take the completed gallery application and minify all of the JS.

### Stu: 06-Stu_Gallery-Optimize

- (20 min)

### Ins: Review

- (5 min)

- Navigate to [06-Stu_Gallery-Optimize/Solved](../../../../01-Class-Content/18-PWA/01-Activities/06-Stu_Gallery-Optimize/Solved) and run the following commands:

  - npm install

  - npm install compression

- Navigate to the [06-Stu_Gallery-Optimize/Solved/server.js](../../../../01-Class-Content/18-PWA/01-Activities/06-Stu_Gallery-Optimize/Solved/server.js)

```js
const compression = require('compression');

app.use(compression());
```

- With these two lines of code we can easily enable GZip compression in our application for our served files.

- Ask the class, "Is Tiny PNG our only option for Image Compression?"

  - We can use many different tools when looking to compress images. For our purposes we chose to use Tiny PNG for its ease of use. Feel free to research other image compression tools if you'd like to dive deeper.

  - We will not go through the process of compressing all of the images as we did that earlier in the class, but image compression is an important and easy way to decrease load times.

- Ask the class, "Can you see the ways you can use these performance enhancements in your existing applications?"

  - Optimizing our applications to be performant on all devices and connection speeds will make us better developers. We need to consider those with smaller devices or slower speeds at all times as to not alienate any user base.

### Ins: End (0 min)

- Congratulate students on beginning their journey into web performance. They learned a lot today, let them know they did a good job.

- Answer any questions before wrapping up.
