# 18.3 - Intro to Webpack (10:00 AM)

### Ins: Welcome/Intro Webpack

- 10-1010 (10 min)

- today we will cover how we bundle JavaScript files using Webpack to improve performance

- what have we leaned to help with perf so far?

  - compression, minification, lazy-loading and caching

  - do we minify by hand every time we make a change? (of course not - annoying and what if we have dependencies)

  - if you remember that we were network bottlenecked at about 6 requests, how can we fix that?

    - bundle multiple files into a single file

- webpack analyzes the dependencies of your project to create one ore more bundles

- if you remember, browsers can only handle so many concurrent connections (about 6)

  - bundling our javascript files reduces the number of network requests

  - having something automatically combine them prevents us from having to develop in a monolith

  - modules are going to become standard in JS but are not well-developed yet (ESM - ECMAScript Modules)

  - can be extended to support more than JS (CSS, HTML, etc.)

  - supports transpilation with babel

  - supports tree shaking

  - minification

  - hot reloading

  - more

### Ins: 15-Ins-Webpack-Intro

- 1010-15 (5 min)

- Install webpack dev dependencies

  - `npm i -D webpack webpack-cli`

  - show `package.json`

    - add `"build": "webpack --watch"` to have webpack build our project anytime files change

- `webpack.config.js`

  - webpack uses a config file for its options, we will spend a significant amount of time tweaking this today

  - `entry` the main JavaScript file from which a dependency graph can be generated

    - show `src/app.js`

  - `output` how to output bundles

  - `mode` allows us to have different configs for production and development

    - ask: why would we want this? (optimize readability in development, optimize performance in production)

- run `webpack`

  - creates `dist/bundle.js`

  - it looked at `app.js` and setup a dependency graph

    - right now `app.js` does not require anything so the graph is a single node - we'll update that in a bit

  - lots of webpack setup at the top and then our `console.log` at the bottom

  - it generated this using a dependency graph starting at `app.js`

- `index.html`

  - we don't have to specify each file individually any more, just a reference to the bundled set of files

  - open the file (we see the log)

  - show the sources

  - change the log

- add a dependency

  - `src/pizza.js`

    ```js
    'use strict';

    function eat(numPizzas) {
      console.log(`Ate ${numPizzas} pizzas!`);
    }

    module.exports = {
      eat
    };
    ```

  - `src/app.js`

    ```js
    'use strict';

    const pizza = require(`./pizza`);

    console.log(`Hello webpack!`);
    pizza.eat(10);
    ```

### Stu: 16-Stu-Webpack-Intro

- 1015-25 (10 min)

- try adding webpack to a budgeting website

### Instructor Do: Review

- 1025-30 (5 min)

- show `package.json`, `webpack.config.js`

- `app.js` depends on `calculations.js` (require and export kind of like node)

  - without webpack we would not be able to do this `require` in the client-side

- in `dist/bundle.js` it takes this dependency graph into account

  - we can see a `__webpack_require__` to pull in calculations

### Ins: 17-Ins-First-Plugin

- 1030-35 (5 min)

- plugins and loaders are the two main pieces of webpack we will work with, let's add a plugin to visualize the size of our project

- according to webpack "Plugins are the backbone of webpack"

  - they enable third parties to add functionality to webpack that aren't built-in by default. There are thousands of plug-ins which do everything from asset management, bundle optimization to adding PWA capabilities.

- show `package.json`

- show `webpack.config.js`

- `npm run build`

  - `webpack-bundle-analyzer` will auto open http://127.0.0.1:8888 with a treemap

  - using `webpack-bundle-analyzer` we can see the impact libraries have on the bundle size

    - `stat size`: source size before transformations

    - `parsed size`: output size

    - `gzip`: after compression

- most of our code are dependencies like `chart.js`

- `moment.js` is a dependency on `chart.js` so it gets included as well

### Stu: 18-Stu-Webpack-Plugin

- 1035-45 (10 min)

### Ins: Review

- (5 min)

- Run the following commands to start the application:

```bash
node seeders/seed.js
npm install
npm start
```

- Navigate to [http://localhost:3000](http://localhost:3000) in your browser and point out the following:

  - If we inspect our Service Worker with DevTools, we see that `dist/bundle.js` is cached.

  - Additionally, "Service Worker registered successfully" was logged to the console.

- Open `public/webpack.config.js` in your IDE and point out the following:

  - The first plugin, `SWPrecacheWebpackPlugin` allows us to cache our external project dependencies. It generates a service worker using an existing service worker and adds it to our build directory.

  - The second plugin, `WebpackPwaManifest` generates a manifest.json file to be included in our build directory. While most of the properties are the same as a regular manifest.json, this plugin also automatically resizes all of our icons to the appropriate sizes and allows for the use of ES6 features and JavaScript comments.

```js
plugins: [
  new SWPrecacheWebpackPlugin({
    cacheId: "my-domain-cache-id",
    dontCacheBustUrlsMatching: /\.\w{8}\./,
    filename: "service-worker.js",
    minify: true,
    staticFileGlobsIgnorePatterns: [/\.map$/, /manifest\.json$/]
  }),
  new WebpackPwaManifest({
    name: "Images App",
    short_name: "Images App",
    description: "An application for images",
    background_color: "#01579b",
    theme_color: "#ffffff",
    "theme-color": "#ffffff",
    start_url: "/",
    icons: [
      {
        src: path.resolve("public/assets/images/icons/android-chrome-192x192.png"),
        sizes: [96, 128, 192, 256, 384, 512],
        destination: path.join("assets", "icons")
      }
    ]
  })
],
```

- Open `package.json` in your IDE and point out the following:

  - Our plugins must be installed as devDependencies.

  - We've also added the script "build", which is a built in npm script that will automatically run before each time `npm start` is run.

### Ins: Demo Pure Functions

- (10 min)

- The next demo is going to use a couple of ES6 features that aren't supported in all browsers.

  - What tool do you think we will need to use to allow us to use ES6 in all browsers?

  - Babel. This is true, but in order to use Babel with our Webpack build we will need to utilize a Babel feature known as a **loader**.

  - Normally, Webpack only knows how to process regular JavaScript. Loaders allow Webpack to compile and bundle non-JavaScript resources like CSS, HTML, TypeScript, and more. Specifically, the Babel loader goes through all of our JavaScript files and transpiles ES6 into ES5.

- Open `16-Ins-Pure-Functions/webpack.config.js` in your IDE and point out the following:

  - We've created a new object called module and within it define an array of rules.

  - `test` is a regular expression that describes the files that you want to match.

  - Since Babel loader is pretty slow, it is especially important that you define an `exclude` property that contains a regular expression that matches all files in your `node_modules` directory.

  - The `use` property is where we define which loader we are going to use, along with any presets or configurations to pass to the loader. Here, we are telling Webpack to use the babel-loader for all JavaScript files that are not in `node_modules`, and to use a preset called `@babel/preset-env`.

```js
module: {
  rules: [
    {
      test: /\.m?js$/,
      exclude: /(node_modules)/,
      use: {
        loader: 'babel-loader',
        options: {
          presets: ['@babel/preset-env']
        }
      }
    }
  ];
}
```

- Now that we've added our loader, we need to install Babel itself, the loader, and any presets that we want to use.

- Run `npm install @babel/core babel-loader @babel/preset-env -D` from the command line.

- Open up `src/app.js` and point out the reorganization of the files.

- We have added the `Chart.js` library so that we can see a bar chart of our expenses.

  - Remember, Webpack allows us to import other npm modules into our application.

  - We've separated the files into files like `elements.js` and `expenses.js` to help further modularize our code. There is no definitively "right" way to split up your code. The main goal when refactoring code to be split between files is to create functions that are reusable and relatively "pure", when possible.

  - What does it mean for a function to be pure?

  - Pure functions are straightforward with singular purposes. They do not have any "side effects" within them. **Side effects** are bits of code that interact with the outside world like database calls or changes to the DOM.

  - In pure functions, whenever data needs to be modified, it is not mutated. Instead, we create a new variable that describes the new mutation. Pure functions have the advantage of being easily testable and reusable. It is considered best practice to use pure functions whenever possible.

  - What does it mean for a function to be impure?

  - Impure functions tend to have multiple purposes. The might contain database or network calls. Even though it is preferred to keep your functions simple, impure functions are often unavoidable.

- Open `src/calculations.js` in your IDE and point out the following:

  - The `subtract` function is a pure function. It creates a new variable for the result, instead of modifying the input and contains no side effects.

  ```js
  export function subtract(a, b) {
    const result = a - b;
    return result;
  }
  ```

- Open `src/app.js` in your IDE and point out the following:

  - The `submit` function is an impure function. It modifies existing values and has multiple side effects.

  ```js
  function submit() {
    const total = subtract(Number(balanceEl.innerText), priceEl.value);
    balanceEl.innerText = total;
    addToList(expenseEl.value, priceEl.value);
    updateChart(expensesChart, expenseEl.value, priceEl.value);
  }
  ```

- Run `npm install` in your terminal and open `index.html` file in your browser and demonstrate the following functionality:

  - The submit button adds new expenses to the list.

  - The chart is updated with the new expenses.

### Stu: Gallery Pure Functions

- (15 min)

### Ins: Review

- (10 min)

### Ins: Demo Lazy Loading JavaScript

- (10 min)

- Tell the class that just like the lazy loading they worked with using Images, JavaScript can also be loaded as needed.

  - What is lazy loading?

  - Lazy loading allows us to load resources on an as-needed basis, instead of on page load.

  - If there is JavaScript specific to a part of the page a user is using, when do you think it should be downloaded?

  - We should only download the JavaScript specific to a part of the page when the user navigates to that page.

  - Could deferring the downloading save us time on page load?

  - Absolutely. Longer bundle sizes result in longer load times.

- Open `18-Ins-Chunking/webpack.config.js` in your IDE and point out the following:

  - We have added a second entry point to our bundle. This entry point is `chart`.

  - `chart` points to `./src/expenseChart.js`.

  - `filename: "[name].bundle.js"` dynamically names our bundle after the name of the entry point. For instance, the entry point `chart` will create a bundle named `chart.bundle.js`.

  - By creating multiple entry points, we can defer the loading of a particular bundle until the code required is needed.

- Open `chart.html` and point out the following:

  - We've added a `<script>` tag to our html that loads our `chart.js` JavaScript bundle.

```html
<script src="./dist/chart.bundle.js"></script>
```

- Open `07-Ins-Chunking` in your IDE and run the following commands from your command line:

  - `npm install`

  - `npm run build`

- Open the `index.html` in your browser and point out the following:

  - If we inspect out Network in DevTools, we can see that the chart.js has not been loaded yet.

  - Only once we click the `chart` link in the navbar of the page does the `chart.js` bundle load.

  - What are the possible setbacks of this method?

  - If both of our bundles require some of the same dependencies, those will be included and both bundles and thus we will end up with duplicated code between bundles.

### Stu: Gallery Lazy Loading JavaScript

- (15 min)

- Direct students to the activity instructions found in `22-Stu-Chunking`

```md
- Run `npm install`.

- In `webpack.config.js`, add entry points for JavaScript files for the three pages, home, detail, and favorites.

- Update `service-worker.js` file so that it caches the new bundles.

- Make sure to update each html file so that it also uses the appropriate bundle.

- Note that the gallery application has been upgraded with the ability to save your favorite images to IndexedDb.

- Once again, there are many ways that you can separate your JavaScript files. It is recommended that you create somethings similar to the following file structure to avoid chunking unused code:

  - `api.js` Loads images from the api.

  - `cardCreation.js` Responsible for all functions related to the creation of cards.

  - `domMethods.js` Responsible for all functions related to manipulating the DOM.

  - `detail.js` Responsible for the Detail page of the application.

  - `favorites.js` Responsible for the Favorites page of the application.

  - `home.js` Responsible for the Home page of the application.

  - `indexedDb.js` Contains a helper method to interact with IndexedDb.

  - `rating.js` Handles the creation of the ratings form and the update method.

- Adjust the files in the `FILES_TO_CACHE` array within `public/service-worker.js` so that the Webpack bundle is cached instead.

- Run `npm start` and make sure that the application still works as expected.

- Navigate to each page and make sure that the bundle files are all being cached by the service worker.

### Hints

- Try testing out functionality of the application at [http://localhost:3000](http://localhost:3000) every time you make changes. This will help you identify the code that does not work as expected.

- If extracting functionality from a JavaScript file causes any of the pages to stop working, do **not** continue until you understand why it's not working as expected.

- Ask the instructor or a TA for help if get stuck or are unsure why a function isn't working.
```

### Ins: Review

- (10 min)

- Open `22-Stu-Chunking/Solved/webpack.config.js` in your IDE and explain the following:

  - There are now three entry points designated.

  ```js
  entry: {
          app: './public/assets/js/home.js',
          detail: './public/assets/js/detail.js',
          favorites: './public/assets/js/favorites.js'
      },
  ```

  - We also used the `[name].bundle.js` syntax in our output to dynamically name our bundle after the entry point it was built from.

  ```js
  output: {
          path: __dirname + '/public/dist',
          filename: '[name].bundle.js',
      },
  ```

- Now run the following commands from the command line:

  - `npm install`

  - `npm run watch`

  - In the console, we have 3 `bundle.js` files and the bundle naming aligns with the entry points provided in the `webpack.config.js`

- Run the following command from the command line: `npm run webpack`

- In your browser, navigate to [localhost](https://localhost:3000) and explain the following:

  - If we open up our `Network` tab and toggle JS, we can click a picture's name and see that `detail.bundle.js` is loaded when we bring the details of an image.

- In your browser, click on the link to the favorites page and point out the following:

  - `favorites.bundle.js` loads.

  - Lazy loading is a great way to defer loading of resources that are not necessary, but there are possible problems it can raise.

  - Most notably, if multiple entry points have some of the same dependencies, those dependencies will be duplicated across bundles.

### BREAK

- (40 min)

### Ins: Introduce Mini-Project

- (5 min)

- Run the following commands from the command line:

  - `npm install`

  - `npm run watch`

- Navigate to [localhost:3000](http://localhost:3000) in your browser and point out the following:

  - Newsy is a news aggregator app that allows us to search for articles classified by topic, then save our favorites.

  - The home page of the application has some default topics, but we can create your own or remove the default topics.

  - Clicking on one of the topics causes the page to display a list and allows us to save each article to our favorites.

  - Saving a couple of articles to our favorites causes the button to update to a _remove_ button.

  - Navigate to the favorites page in your browser and point out the following:

    - The favorites we selected are listed.

    - The favorites data was stored in IndexedDb, since we are not using a local database for this application.

# 16. Student Do: Work on Mini-Project

- (60 min)

# 17. Instructor Do: Review Mini-Project

- (15 min)

- Open `index.js` in your IDE and point out the following:

  - All of the functions pertaining to the `home` page are in `index.js`.

  - `createElement` is brought in from the `domMethods.js` file.

- Open `domMethod.js` in your IDE and point out the following:

  - It is not entirely necessary for us to understand exactly how every line in `createElement` works.

  - It is valuable to get practice working with code we do not fully understand because new developers almost always start their careers working with an unfamiliar codebase.

  - The `createElement` function returns a DOM element and has the following parameters:

  1. A string that represents the type of element.

  2. An object containing all of the attributes to add to the element.

  3. 1 or more children elements to be appended to the element.

  - The `createArticle` function uses a ternary expression to render a `Save to Favorites` button or a `Remove from Favorites` button depending on whether the article is already part of the user's favorites.

  - `loadPage` is a callback passed to the `createElement`. The actual function will either use the results from an AJAX request or the results from IndexedDb to render the page, depending on which function was passed through as a callback.

  - `createPlaceholders()` displays placeholders so that content is rendered on the page while the user waits for results from the AJAX request. Although they will only display on the page for a few seconds, they play a significant role in increasing the user's experience on the site.

- Open `topic.js` in your IDE and explain the following:

  - When the `Topic` page is opened, `useIndexedDb` is called to check if any of the articles have been favorited. This is necessary so that articles that have already been saved to the user's favorites can display a `Remove from Favorites` button.

- Open `service-worker.js` in your IDE and point out the following:

  - Each html file should be cached with its respective bundle.

- Open `webpack.config.js` in your IDE and point out the following:

  - There are 3 different entry points created for each app.

  - Each bundle will include all dependencies brought into each entry file with ES6 `import`.

- Although most of the configuration can vary, depending on the app, it's important that the icon `src` points to a valid path to an icon for the application.

- If time permits, ask the students if there are any parts of the application that they would like to spend more time going over.

  - Some students may be frustrated with the amount of time they needed to spend refactoring code so that it could be easily chunked by webpack.

  - If this is the case, remind students that one of the main motivations behind chunking is reducing the bundle size of your code. While there are many strategies one can take to split up their code, it is important that it's split in a way that makes the code reusable and clear in purpose. Sometimes this means large amounts of refactoring functions. This is time well spent since they are making their code easier to test and easier for other developers to work with.
