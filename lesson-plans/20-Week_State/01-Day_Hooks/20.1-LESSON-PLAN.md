# 20.1 - Intro to React Hooks

### Ins: Hooks Slide and Discussion

- 630-50 (20 min)

### Ins: Intro

- TODO: live code a simple example

### Ins: 01-Ins_useState

- 650-7 (10 min)

- 'status' defaults to 'content'

- 'encourage laziness' switches it to 'lazy'

- `App.js`

  - import `useState`

- we call `useState` initializing the state

  - built-in hook that always returns an array of two elements

    - current state

    - function to overwrite the current state

  - state is destructured to get each of these out as `developerState` and `setDeveloperState`

  - when called we need to use the spread syntax because it will overwrite the state, unlike `setState`

### Stu: 02-Stu_useState

- 7-15 (15 min)

- signup page, have it update the page using `useState`

- if behind make this 10 minutes

### Ins: Review

- 715-25 (10 min)

- `src/pages/Signup/index.js`

  - no default values

  - we don't use `value`, we use `onChange`

    - This is for a controlled input

      - **Controlled input** accepts its current value as a prop and has a callback that allows you to change its value. Whenever `onChange` updates its value, it's essentially the input controlling itself.

      - **Uncontrolled input** is an input that gets its value from somewhere else. In our case, if `value={username}`, then the input would be getting its value from the state.

      - The combination of the two would result in the component going from uncontrolled to controlled, which is considered bad practice.

### Ins: 03-Ins_useEffect

- 725-35 (10 min)

- effect meaning side effect

  - this can be manipulating the DOM (outside of our component), setting up a subscription or manipulating data in a database

    - it is a combined `componentDidMount`, `comonentDidUpdate` and `componentWillUnmount`

    - these should happen after render, we want them to happen after React updates the DOM

- if you are changing something outside of the react component, you are creating an effect that should be managed with `useEffect`

- "Think of effects as an escape hatch from Reactâ€™s purely functional world into the imperative world" -React

- effects run after every completed render, can opt to only fire them when certain values have changed

- a returned function inside `useEffect` allows cleanup opportunity

  ```js
  useEffect(() => {
    const subscription = props.source.subscribe();
    return () => {
      // Clean up the subscription
      subscription.unsubscribe();
    };
  });
  ```

  - `useLayoutEffect` is a related hook that is fired synchronously before the next paint

  - the second argument to `useEffect` is an array of the values (props or state) that the effect depends on to limit how frequently it is fired

    - an empty array means that you don't depend on any values from props or state so it never needs to re-run

- `App.js`

  - `useEffect` has two parameters

    - function to run after the component mounts

    - array of dependencies (deps)

      - every time the component re-renders the `useEffect` hook will check if any values in its dependency array have changed. If so, it runs the function again.

- demo clicking the buttons

  - useEffect is called after the API call completes

### Stu: useEffect Activity

- 735-55 (20 min)

### Ins: Review

- 755-805 (10 min)

- The application immediately queries the Wikipedia API based on input.

- Open `11-Stu-useEffect/Solved/src/pages/Search/index.js` and explain the following:

  - All of the states have been set up at the top of the file.

  ```js
  const [search, setSearch] = useState('Wikipedia');
  const [title, setTitle] = useState('');
  const [description, setDescription] = useState('');
  const [url, setUrl] = useState('');
  const [error, setError] = useState('');
  ```

  - `search` is the only term provided with a default value. We could also create a single object to hold the values, but in using separate Hooks our code is more readable and manages state better. We pass `search` to the `useEffect` hook in the 'deps' array. `useEffect` will run when the component mounts, then after each time the value in the search input field changes.

  ```js
  useEffect(() => {
    document.title = 'Wikipedia Searcher';
    if (!search) {
      return;
    }
    API.searchTerms(search)
      .then(res => {
        if (res.data.length === 0) {
          throw new Error('No results found.');
        }
        if (res.data.status === 'error') {
          throw new Error(res.data.message);
        }
        setTitle(res.data[1]);
        setDescription(res.data[2][0]);
        setUrl(res.data[3][0]);
      })
      .catch(err => setError(err));
  }, [state]);
  ```

  - The `if(!search)` conditional ensures that we do not run a query if the input field is empty.

  - The `handleInputChange` method now simply uses our `setSearch` hook.

  ```js
  const handleInputChange = event => {
    setSearch(event.target.value);
  };
  ```

- Ask students the following questions:

  - What was the point of this? (Feel free to make a bad pun here).

  - Writing functional components is much cleaner. Using Hooks allows you to write fewer lines of code and manage your state in a less complex way. (No `this` keyword required!)

  - If we use Hooks, can state be used by other components?

  - No. The state used within a single component cannot be used by different components.

  - Can you think of a concept that would allow us to share state across components?

  - We can add this functionality by using the Context API with the built in `useContext` Hook.

### BREAK

- 805-20 (15 min)

### Ins: Custom Hooks Demo

- 820-30 (10 min)

- Take a moment to ask the class to recite the two rules of Hook.

  - Only call Hooks from top-level components. This means **never** call Hooks from within loops, conditionals, or nested functions.

  - Hooks may only be called from React components. **Never** call a Hook from a regular JavaScript function.

- Next, introduce the class to the concept of custom Hooks. Remind the class that the two rules of Hooks still apply to custom Hooks.

  - Custom Hooks can be practically anything! Custom Hooks are best suited to extract logic that may be repeated.

  - Custom Hooks are a great way to keep your React functions pure.

- In addition to the two rules of Hooks, let students know that custom Hooks must start with the word `use` so that React can ensure that your code is adhering to the two rules of Hooks.

- Let students know that just as with `useState` and `useEffect`, different components that use the same custom Hook do **not** share the same state. If you wish to have two components that use the same state, you should use `useContext` or combine and custom Hook with `useContext`.

- Open [CustomHook Demo] in your browser.

  - Show students that when you change the value of the `name` input field, the corresponding section in the card updates.

  - Open the console and demonstrate that every change in either field causes an object to be logged.

- Open [useUserModel.js] in your IDE.

  - The purpose of this Hook is to control the user model. Each property of the `userModel` will be an object with the properties `value` and a method for changing the value named `onChange`.

  - Point out that the Custom Hook is a top level function. Within it we can use Hooks like `useEffect` and `useState`.

  - Our Hook starts with the word `use` so that we can easily identify it.

  - We set the `nameState` and `statusState` to have default string values. ImageState is set to a default image from our `assets` directory.

  - The Hook returns an object with an `error` property that will return an error if the `nameState` is ever left empty.

  ```js
  import { useState } from 'react';

  import profileImage from '../assets/images/profile.png';

  const useUserModel = () => {
    let [nameState, setName] = useState('Bob');
    let [statusState, setStatus] = useState('Excited');
    let [imageState, setImage] = useState(profileImage);

    return {
      error: nameState === '' ? 'Please enter a name' : '',
      name: {
        value: nameState,
        onChange: e => setName(e.target.value)
      },
      image: {
        value: imageState,
        onChange: e => setImage(e.target.value)
      },
      status: {
        value: statusState,
        onChange: e => setStatus(e.target.value)
      }
    };
  };

  export default useUserModel;
  ```

- Open [App.js] and explain the following:

  - Our state is managed with a Context Object called `UserContext`.

  - The `useEffect` hook is **only** being used to show the developer every time that `userModel` changes.

  ```js
  import React, { useEffect } from 'react';
  import './App.css';

  import useUserModel from './utils/useUserModel';
  import UserContext from './utils/UserContext';
  import UserCard from './components/UserCard';
  import UserForm from './components/UserForm';

  const App = () => {
    const userModel = useUserModel();

    useEffect(() => {
      console.log(userModel);
    }, [userModel]);

    return (
      <div className="container text-center">
        <h1 className="mt-4 mb-4">Welcome to the Person Creator!</h1>
        <div className="jumbotron">
          <UserContext.Provider value={userModel}>
            <UserForm />
            <UserCard />
          </UserContext.Provider>
        </div>
      </div>
    );
  };

  export default App;
  ```

### Stu: Custom Hooks

- 830-45 (15 min)

- Introduce [CustomHook Unsolved]

- In this activity we will practice using Custom Hooks by creating a `useDebounce` Hook that will delay the invoking of a function for a given number of milliseconds.

### Ins: Review

- 845-55 (10 min)

- Open [15-Stu_CustomHooks/] in your browser.

  - Type `software developer` into the Article Search Bar.

  - Point out that the article below the search bar only updated once you finished typing.

  - Slowly type out each letter of `software developer` and demonstrate that the API call occurs if there has been a period of over 500 milliseconds without any input changing.

- Open [15-Stu_CustomHooks/Solved/src/utils/debounceHook.js] in your IDE and point out the following:

  - We will use the `useEffect` and `useState` Hooks in our custom Hook.

  - Our Custom Hook starts with the word `use`.

  - `useDebounce` takes in two parameters: `value` and `delay`.

  - The state is controlled with a Hook at the top level of our `useDebounce` Hook.

  - We create a `setTimeout` method and set it to a variable called `handler` so that we may later `clearTimeout`.

  - We `return` a function that clears the timeout.

  - Inside the `useEffect` Hook, if a `return` statement is provided, then the function that is returned gets run every time the component unmounts **or** right before the next `useEffect` is called. This is known as a "cleanup" function because it is designed to tie up the loose ends in effects that are dependant on outside effects. In our case, the outside effect is the `handler` timeout we created.

  ```js
  import { useEffect, useState } from 'react';

  const useDebounce = (value, delay) => {
    const [debouncedValue, setDebouncedValue] = useState(value);
    useEffect(
      () => {
        const handler = setTimeout(() => {
          setDebouncedValue(value);
        }, delay);
        // Cancel the timeout if value or delay changes
        return () => {
          clearTimeout(handler);
        };
      },
      // Only call the effect if value or delay changes.
      [value, delay]
    );

    return debouncedValue;
  };
  export default useDebounce;
  ```

- Open [15-Stu_CustomHooks/Solved/src/utils/debounceHook.js] in your IDE and point out the following:

  - The `debouncedSearchTerm` variable is set up **outside** of the `useEffect` Hook. We pass in the existing `search` variable that is tied to our component state and pass in 500 as our second parameter.

  - First, we will check to make sure that the input text is not empty.

  - Then we ensure that `debouncedSearchTerm` is not `undefined` or `null`.

  - `useEffect` receives `debouncedSearchTerm` so that it will only run when the debounced term changes instead of running whenever `search` changes.

```js
const debouncedSearchTerm = useDebounce(search, 500);

useEffect(() => {
  document.title = 'Wikipedia Searcher';
  if (!search) {
    return;
  }
  if (debouncedSearchTerm) {
    API.searchTerms(search)
      .then(res => {
        if (res.data.length === 0) {
          throw new Error('No results found.');
        }
        if (res.data.status === 'error') {
          throw new Error(res.data.message);
        }
        setArticleState({
          title: res.data[1],
          description: res.data[2][0],
          url: res.data[3][0]
        });
      })
      .catch(err => setError(err));
  }
}, [debouncedSearchTerm]);
```

### Stu: Third Party Hooks

- 855-915 (20 min)

- If time permits, introduce students to [16-ThirdPartyHooks/Unsolved/]. Since this activity uses third party Hooks, only proceed with this activity if the students seem to have a solid grasp of Hooks. Otherwise, spend the rest of class answering lingering questions, reviewing, and skimming over the solution with the class.

  - In this activity we will practice using third party Hooks. Specifically, we will be creating a survey form using the `react-hanger` package on npm.

  - Let the students know that `react-hanger` is one of many custom Hooks packages on GitHub. This package contains multiple custom

  - Start the application in dev mode by running `npm run watch` in your terminal.

  - Open your browser toÂ [localhost:3000](http://localhost:3000)Â and study the rendered application.

    - There are a few fields in our survey form. Before writing any code, try thinking about how you would manage the state of this form.

  - Navigate to the [react-hanger docs](https://github.com/kitze/react-hanger) familiarize yourself with the `useInput`, `useBoolean`, and `useNumber` Hooks.

  - Update this application to accomplish the following:

    - Each user input should be handled using the `react-hanger` Hooks.

    - When the user clicks an emoji, indicate which type of response they selected by displaying the text: `You responded that you feel FEELING`. `FEELING` should be replaced with the value of the emoji that they clicked.

    - Make your survey form a little more dynamic by displaying a field for additional comments when the user clicks on an emoji.

    - When the form is submitted, `console.log` an object containing all of the values from the form.

### Ins: Review

- 915-25 (10 min)

- Replace your React application's src directory with [16-ThirdPartyHooks/Solved].

- Demonstrate that the application satisfies the requirements:

  - Fill out each field in the form with dummy data.

  - Click `submit`.

  - Open the console and show that the form object contains the value from each field.

- Open [Survey/index.js solved] in your IDE and demonstrate the following:

  - Even though we used `textarea` instead of `input`, we can still use the `useInput` hook.

  - `showComment` is initialized to `false` so that the additional input field is not visible initially.

  - Since we will be setting the rating manually, we do not need to give it upper and lower bounds.

  ```js
  const favoriteThing = useInput('');
  const showComment = useBoolean(false);
  const comment = useInput('');
  const feeling = useInput('');
  const rating = useNumber(0);
  ```

  - Our form object contains the value of each field. Since `showComment` is only used for display purposes, we do **not** include it in the form object.

  ```js
  const handleSubmit = () => {
    const form = {
      favoriteThing: favoriteThing.value,
      comment: comment.value,
      feeling: feeling.value,
      rating: rating.value
    };
    console.log(form);
  };
  ```

  - `...favoriteThing.eventBind` binds both the `value` and the `onChange` props of an element, as long as it has a `event.target.value`.

  - This single method would also work with input fields and select elements.

  ```js
  <textarea {...favoriteThing.eventBind} />
  ```

  - It is very important that we include `role="img"` and `aria-label="angry"` to make the emojis accessible.

  - The onClick method toggles our `showComment` boolean and sets the feeling value to angry.

  ```js
  <span
    role="img"
    aria-label="angry"
    onClick={() => {
      showComment.toggle();
      feeling.setValue('angry');
    }}
  >
    ðŸ˜ 
  </span>
  ```

  - We use a ternary operator so that the additional comments textarea only renders if the `showComment` boolean is true.

  - Once again, `onClick` and `value` are bound to the comment variable.

  ```js
  <div className="response">
    {showComment.value ? (
      <textarea
        {...comment.eventBind}
        placeholder="Please add any additional comments"
      />
    ) : null}
  </div>
  ```

- Recommend students go through the following material at home before next class if possible. These articles will help them better understand the material covered today in class.

- [React Hooks Docs](https://reactjs.org/docs/hooks-intro.html)

- [A Complete Guide to useEffect()](https://overreacted.io/a-complete-guide-to-useeffect/)

- [List of React Hooks](https://nikgraf.github.io/react-hooks/)
