# 20.3 - State Management with the Store

## Overview

In this class, students will learn the benefits of declarative Redux-style code and implement an architecture that mirrors Redux with a store, reducer, and actions.

- You should scaffold out a React application with Create React App at the beginning of class and suggest students do the same. The activities we go over today will only include the applications `src` directory which you should replace in your React app's boilerplate to avoid repetitive installs. It's recommended that you completely restart the dev server between activities.

- Today's lesson will rely heavily on Redux concepts. It is recommended that you spend some time getting familiar with the activities before class starts.

## Learning Objectives

- Transform an app that manages state in Container components into one that follows a Redux pattern.

- Identify the appropriate time to make a React app use Redux or follow a similar design pattern.

- Grasp general concepts of declarative, pure, immutable functions, in a way that is abstracted from Redux or any particular library.

- Implement a Redux-like store in a React app.

### Ins: Introduction

- 10-10 (10 min)

- first half of class we will learn about Redux

- second half will be a mini-project to create your own CMS (content management system) with redux

### Ins: 16-Ins_useReducer

- 1010-20 (10 min)

  - The application is similar to earlier click counter demos

  - Clicking the `Add` or `Subtract` buttons increments and decrements the numerical value accordingly

- Open [App.js] in your IDE and explain the following points:

  - We import the `useReducer` method from `react`.

  - Within our `App` component, we invoke the `useReducer` method, and, using array destructuring, capture the returned value in `count` and `dispatch` variables.

  - Similar to the `reduce` array method, `useReducer` expects to receive two arguments, a function with `state` and `action` values, and an initial state value, which we set here to `0`.

  - When a button is clicked, `dispatch` is passed either an `add` or `subtract` value and, based on the conditional logic in the anonymous function passed to `useReducer`, it will increment or decrement state accordingly.

### Stu: 17-Stu_useReducer

- 1020-35 (15 min)

### Ins: Review

- 1035-45 (10 min)

- Open [App.js solved] and explain the following:

  - This application keeps track of how many times you've praised each dog.

  - Our reducer allows for two different actions. For simplicity's sake, we've hard-coded `praiseHarry` and `praiseHermione` as separate actions.

  - Ask the students the following questions:

  - How might we rewrite our reducer so that any number of dogs can be praised?

  - We could create a single case that handles all actions in a similar manner. This way, the initial state would also have to into an array, so that the dogs would be easy to iterate through.

  - What logic in our reducer is repeated that we might be able to extract?

  - The return statements are almost identical. A more scalable solution might update a `praises` property on a `dog` object. The action would contain a unique identifier so that the proper item in the state array could be updated.

  - This time, the initial state value is set to be an _object_ that keeps track of how many praises each dog has.

  - To display each dog, we use the `map` method on our `dogs` array and return a div with a unique key. In this case we can use `item.name` since there are only two dogs. In a larger list of dogs, it would be better to use a unique id.

  - Point out that the code that displays how many times each dog has been praised uses the bracket notation to dynamically grab the dogs name.

  - This workaround is only necessary because our reducer state is an object. If the reducer state was an array, we may be able to utilize the `index` property in `map`.

### Ins: 18-Ins_useRef

- 1045-55 (10 min)

  - Clicking the increment button still works as in the previous demo

  - Entering a new value in the input field updates the counterimmediately.

- Open [App.js solved] in your IDE and explain the following:

  - `useRef` is a Hook that allows you to use the `ref` attribute on an input element. To access the value from a specific input element, we must attach its reference to our new `useRef` hook. The value of the input field is stored in the `current.value` property.

  - Now that we've added another conditional to our reducer, it makes sense to convert it into a switch case statement for better readability.

  - We _did not_ use the `onChange` handler. Although we could have used `onChange`, we opted to make our input field _uncontrolled_, since we only need the value from the field when the form is submitted. Not only does this mean we needed to write less code, but it also means that our component will not be unnecessarily subscribed to a value that is frequently changing.

### Stu: 19-Stu_useRef

- 1055-1110 (15 min)

### Ins: Review

- 1110-20 (10 min)

  - Entering a task in the input field and clicking on `Add to list` creates a new Todos

  - Clicking the `Remove` button on any item removes it from the list

- Open [App.js Solved] in your IDE and explain the following points:

  - We initialize a variable, `inputRef` with `useRef`.

  - Our switch case checks the `type` property on the action object.

  - In the `add` case, we return a _new_ array that contains all of the items in the previous state _and_ a new object made up of the `name` property from the action object and a unique id.

  - In order to fake a unique id we generate one from the length of the array. In a full-stack application, the id would be a unique value created by the database.

  - The `remove` case returns a new array that contains every item from the previous array _except_ for the item that should be removed.

  - The `filter` method returns a _new_ array instead of modifying the existing array. This is a good opportunity to remind students that mutations should be avoided inside reducers.

  - `_` is used as a placeholder since we do not intend to use the first argument in the `filter` callback.

  - `inputRef` is attached to the `ref` attribute on our input field.

  - In the `handleSubmit` function, we dispatch a new action that passes the `inputRef.current.value` to our reducer. Remember to access the `current.value` property on the `inputRef` object.

### Ins: 20-Ins_Store

- 1120-30 (10 min)

  - As before, clicking buttons increments or decrements a counter. This time, however, we are going to keep the counter data in a global state object called the **store**.

- Open the `src` directory in your IDE and point out the following:

  - The application has been separated into multiple files so that we create a flow that is more similar to Redux.

- Open [Ins_Store] in your IDE and explain the following points:

  - From our `GlobalState` util, we import a `CountProvider`. We also import a `Count` component.

  - Inside the `App` component, we wrap the children of `App` in a the `CountProvider`.

- Ask the students the following question(s):

  - If we are importing an object named `CountProvider`, what do you think we will find in `GlobalState`?

  - Based on the name `CountProvider`, we can expect to find `createContext` used to create the exported object.

  - If `GlobalState` is performing the function its name suggests, what else might we find in it?

  - We can find `GlobalState` in any component of our application that will need access to the global state.

- Open [Ins_Store] in your IDE and explain the following points:

  - This file contains what is commonly referred to as the **store**. The store is in charge of handling all of the actions that are passed to it from any component in the application. Once a reducer handles an action, it creates a _new_ state and passes it through the Provider to the global Context object.

  - At the top of the file, we create a new Context object. We then use object destructuring so that we may refer to its Provider object as `Provider`.

  - Again, we are checking the `type` property on the action that this reducer will receive from a dispatch. This time, if the action type isn't one of the two cases, we will throw an Error so that we can quickly identify when we've incorrectly implemented an action.

  - The `CountProvider` function takes in a value argument, which we set to be `0` by default, and the properties from our `props` object. It then returns a Provider with `state` and `dispatch` passed through to the Context object.

  - The `reducer` method is set up, abstracted from the `useReduce` Hook. We don't actually attach it to the `useReducer` Hook until we set up the `CountProvider`. This means that if you want to, you can use the same reducer in multiple providers that have different initial states.

  - `useCountContext` is created so that we will not have to import both the `useContext` Hook and the `CountContext` object every time we want to use the `CountContext`.

  - Lastly, we export `CountProvider` and `useCountContext`

### Stu: 21-Stu_Store

- 1130-50 (20 min)

### Ins: Review

- 1150-12 (10 min)

  - Add Todos to the list with the input field

  - The remove functionality still works as expected

  - If the `prioritize` button is clicked, the text of the Todo is bolded

- Open `/src/App.js` in your IDE and explain the following points:

  - The two components `Form` and `List` are wrapped in a `TodoProvider`. It is very important that we wrap the entire application with our Provider. Without the Provider, `useTodoContext` will not work in any of the components that it's injected into.

- Open [GlobalState.js] in your IDE and point out the following:

  - The `TodoContext` is provided with default values whose types are consistent with the type we intend to provide later. While this is not required, it is considered best practice.

  - Using object destructuring, we create a new variable for the Provider.

  - The `reducer` function uses a switch case to handle the action that will be passed to `dispatch`. Each case returns a new array. Within the "prioritize" case `map` method, we use `Object.assign` because it creates a _new_ object from the old Todo object and the new value of priority. Both of these methods are essential to ensure that our state stays immutable.

  - `priority: !item.priority` sets the priority value to be the opposite of what it previously was. This means that when the `prioritize` button is pressed, the value is _toggled_ rather than explicitly set.

  - The `TodoProvider` returns a `<Provider>` element that we will use to wrap our entire application with.

  - We create this file in our `GlobalState` so that it can provide access to the `useReducer` method to any component in our application.

- Open [Form.js] in your IDE and point out the following:

  - We import `useRef` from `react` and `useTodoContext` from our store.

  - Within the `Form` component, we create a a new `useRef`, `inputRef`, and call `useTodoContext` so that we can dispatch an action to our `Todo` reducer.

  - Since this form is not responsible for displaying any information from the state, the first variable from our destructured Context array can be `_`.

* `dispatch` is used within `handleSubmit` to dispatch an action that will update the store with each Todo that is created using the `inputRef` we created above.

- The `input` element has a ref attribute of `inputRef` so that we can use the `useRef` Hook to easily grab the value from our input field upon form submission.

- The `form` element has an `onSubmit` callback of `handleSubmit`.

- Open [TodoList.js] in your IDE and explain the following:

  - We again import our store so that we can use the `TodoContext`.

  - Within our `TodoList` component, we use the `index` parameter from our `state.map` callback to number each Todo on the list. Each item contains two buttons with `onClick` methods returning `dispatch`. We pass to `dispatch` either "prioritize" or "remove", respectively, and the index of the list item.

  - `<span className={item.priority ? "font-weight-bold" : ""}>` uses a ternary operator to determine whether or not to bold the Todo.

### Break

- 12-40 (40 min)

### Ins: Demo 22-Stu_Mini_Project

- 1240-45 (5 min)

- Open another tab in your terminal and run `mongod`.

- Return to the tab with the [GlobalState.js] directory open and run `npm install` followed by `npm start`.

  - All of our posts can be viewed on the [http://localhost:3000](http://localhost:3000) page.

  - Start by creating a blog post. Show students that the title and body reset, but the screen name does not.

  - Point out that for a brief second, `Loading...` appears in the top right section of the navigation bar. During this time, the `Save Post` button is also disabled.

  - Point out that there are no favorites yet on the right hand side.

  - Click on `View all posts`, then click on the post that you just created.

  - This will take you to another page where you can view the details of the post.

  - Click on the `Favorite` button, then navigate back to the home page. The post you just selected has been added to the favorite posts list. Show the students that you can remove a post from the favorite posts list by clicking the red `x`.

  - Favorites are only stored in the `store`, not the database.

### Stu: 22-Stu_Mini_Project

- 1245-145 (60 min)

### Ins: Review

- 145-2 (15 min)

- Start by opening [actions.js] in your IDE.

  - First, we exported each string as a `const` so that we won't have to worry about misspelling our actions at any point in our application. This also allows us to take advantage of the autocomplete feature in our IDE.

  - It is also considered best practice in Redux to make all of your action types capitalized. This makes it much easier for you to quickly find actions in your code.

  - Let the students know that we'll return to the `Favorites` actions if there's time.

  - At the top, we import all of the action types from our actions file.

  - Walkthrough each case in our switch statement:

  - `SET_CURRENT_POST` returns a _new_ state object by combining the previous state with the `post` object from the `action`. We also set the loading property in our state to be `false`.

  - `UPDATE_POSTS` also returns a _new_ state object. This time, we created a _new_ array by using the spread operator on the posts array from the action. Again, we set the loading property in our state to be `false`.

  - `REMOVE_POST` returns a _new_ state object. The posts array is created by using the `filter` method on the posts array from our previous state. Remember, the `filter` method returns a _new_ array instead of mutating the existing one.

  - `ADD_POST` returns a _new_ state object. We create a new array from the post object from the `action` and the posts from the previous state. Again, we set the loading property in our state to be `false`.

  - `LOADING` returns a _new_ state object with loading set to `true`.

  - The `Store Provider` uses the `useReducer` Hook so that we can provide the global state to all of our components.

  - The second argument in the `useReducer` Hook is the initial state.

  - `dispatch` is also provided globally so that all components can use the reducer.

- Open [createPostForm.js] in your IDE and explain the following:

  - We create separate `ref`s for each input field.

  - The `useStoreContext` Hook is called so that we have access to the store.

  - `handleSubmit` dispatches the `LOADING` action _before_ calling the API.

  - We save our post with `API.savePost`, then dispatch an action to update the store.

  - Both the `titleRef` and `bodyRef` are set back to empty strings.

  - Each `ref` Hook is attached to its respective input field.

  - The button has a `disabled` attribute that activates if `state.loading` is true.

- Open [PostsList.js] and explain the following:

  - The `removePost` function takes in the id argument and executes `API.deletePost(id)`. Once the deletion is complete, we dispatch an action to remove the post from our store. We pass the id property to the store so that the store will be able to use the `filter` method.

  - `useEffect` is called with no dependencies. This means our `getPosts` method will only run after the component first renders.

  - The ternary operation renders our posts _only_ if there are posts in the state. Otherwise, it will return a heading that let's the user know they haven't created any posts yet.

  - By mapping each one of the posts to a `ListItem`, we can display its properties and pass its `_id` to the `removePost` method.

- Open [Detail] and explain the following:

  - The `useEffect` Hook has no dependencies, so it will only run once when the component mounts.

  - We use `ADD_FAVORITE` and `REMOVE_FAVORITE` actions that mirror the `ADD_POST` and `REMOVE_POST` actions.

  - A ternary operator determines whether to show the `Remove from Favorites` or `Add to Favorites` button based on whether or not the `currentPost` is within the current state's `favorites` array.

* We've reached the end of class! Congratulate your students on their progress with the mini-project. Remind them that controlling their application state with a Redux-like store becomes increasingly helpful as the application gets more complex. Let them know that it's okay if they couldn't complete this activity in an hour. If some students have applications with errors, encourage them to spend some time comparing the differences between the `Solved` version and their own.
