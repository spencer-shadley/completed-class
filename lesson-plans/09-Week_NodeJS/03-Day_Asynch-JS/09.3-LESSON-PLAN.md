# Lesson Plan: Asynchronous JavaScript

## Overview

In this lesson, we will review callback functions and introduce Promises and async/await.

- While you would have naturally explained Promises and asynchronous behavior on a need to know basis before today, now is the time to dive deep and provide more thorough instruction for these topics.

- The most important concept for students to walk away from today understanding better is Promises. If they struggle to understand async/await, assure them that a deeper understanding of Promises makes async/await easier to grasp.

- Congratulate the class on any wins today, many JavaScript developers working in the field are unable to accurately explain many of the topics we'll be covering.

## Learning Objectives

- Describe three approaches for handling asynchronous behavior with JavaScript

- Utilize the axios library to perform AJAX requests

- Chain Promises together to perform asynchronous operations in sequence

- Utilize the Promise constructor to wrap asynchronous behavior in Promise objects.

- Utilize async/await syntax to write asynchronous code

### Instructor Do: Preview

- 10-1010 (10 min)

- Welcome the class to our final lesson of Node.js.

  - The focus of today will be all things async.

  - We'll dive deep into asynchronous callback functions, as well as Promises, special objects used in JavaScript handling asynchronous behavior.

  - What are some examples of asynchronous behavior we've encountered so far with JavaScript?

  - Making AJAX requests, timers, responding to browser events such as clicks, reading/writing to the filesystem.

  - Why do we write "asynchronous" code?

  - Since the JavaScript runtime is single-threaded, we need to write asynchronous code effectively in order to avoid blocking client requests on the server.

- Open [40-Stu_Mini-Project/Solved/Bonus/index.js] in your terminal and run the application.

  - The application should prompt for some basic information such as a name and hobbies. Fill out answers to these questions.

- Once all the prompts have been answered, there should be a new `index.html` file added to the project directory. Open it in your web browser for the class to see.

  - This assignment is like their homework, in which they'll use similar techniques to generate a PDF resume.

- Answer any high-level questions about the Mini Project or lesson ahead before students begin the first activity of the day.

### Students Do: 31-Stu_Callback-Review

- 1010-20 (10 min)

### Instructor Do: Review

- 1020-25 (5 min)

  - Callbacks are often used to handle asynchronous behavior, but callbacks themselves aren't asynchronous

- Open [31-Stu_Callback-Review/Solved/index.js] in your editor and point out the following:

  - We're using the `fs.readFile` function to read the contents of `animals.json`. All the other code is written inside of the `fs.readFile` callback function to ensure it only runs after `animals.json` has been read.

  ```js
  fs.readFile("animals.json", "utf8", function(err, data) {
    if (err) {
      throw err;
    }
  ```

  - Since any data read with `fs.readFile` comes back as a string, we use the `JSON.parse` method to turn the JSON string into a JSON object we can work with.

  ```js
  // Parse the JSON string to an object
  const animalJSON = JSON.parse(data);
  ```

  ```js
  // Create two new arrays to contain the cats and dogs objects
  const dogs = [];
  const cats = [];
  ```

  - We use the `forEach` method to loop through the `animalJSON` and push each animal into either the `dogs` or `cats` array.

  ```js
  // For each element in animal
  animalJSON.forEach(function(animal) {
    if (animal.species === 'dog') {
      dogs.push(animal);
    } else if (animal.species === 'cat') {
      cats.push(animal);
    }
  });
  ```

  - Once the animals are pushed into their appropriate arrays, we use `JSON.stringify` to turn the arrays into strings that can be saved to files. The additional arguments passed to JSON.stringify (`null, 2`) ensures that the JSON string is indented rather than all on one line.

  ```js
  // Turn the arrays into JSON strings so they can be written to files
  const dogJSON = JSON.stringify(dogs, null, 2);
  const catJSON = JSON.stringify(cats, null, 2);
  ```

  - We use the `fs.writeFile` method to write the `dogs.json` and `cats.json` files.

  ```js
  fs.writeFile("dogs.json", dogJSON, function(err) {
    if (err) {
      throw err;
    }

    console.log("Successfully wrote to dogs.json file");
  });

  fs.writeFile("cats.json", catJSON, function(err) {
    if (err) {
      throw err;
    }

    console.log("Successfully wrote to cats.json file");
    });
  });
  ```

  - Which of these callback functions are asynchronous? Which are synchronous?

  - The callbacks used with `fs.readFile` and `fs.writeFile` are asynchronous, but the callback used with `forEach` is synchronous.

  - Are callback functions synchronous?

  - Callback functions themselves aren't asynchronous any more than regular named functions are.

  - Do we have to wait on callbacks?

  - Callback functions _are_ often used to describe behavior that should happen at a later time. But in the case of `forEach`, the provided function is run once for each element in the array in a synchronous loop. The callback function is run right away, there's nothing to wait for.

  - So how is `fs.readFile` asynchronous?

  - In the case of `fs.readFile`, it takes a certain amount of time to read from the filesystem and the data isn't immediately ready. So the callback function passed into `fs.readFile` is considered asynchronous since it might run after a few milliseconds, a second, or even a minute. Any remaining synchronous code will continue running while the filesystem is being read without waiting for it.

  - How can we be sure if a function is running synchronously or asynchronously?

  - When in doubt whether a callback is running synchronously or asynchronously, we can check the documentation for the function being used would be a good idea.

### Instructor Do: Axios Demo

- 1025-30 (5 min)

  - Axios works similarly to `$.ajax` in jQuery

- Axios is a third party npm package so must be installed and required

- How have we performed AJAX requests in the past?

- We used the jQuery `ajax` method.

- When writing server-side code, can we use jQuery?

- No, jQuery is a front-end library. It depends on certain browser APIs that don't exist in a node context.

- So why can jQuery be downloaded as a node module?

- While jQuery can be downloaded as a node module, it's not meant for use on the backend, so we need another solution such as the axios library.

- Open [32-Ins_Axios-Demo/index.js] in your IDE and point out the following:

  - We're requiring the `axios` library. Axios is a third-party npm package, i.e. it's not built-in to node and must be downloaded and added to your `package.json` via `npm install axios --save`.

  ```js
  const axios = require('axios');
  ```

  - Axios has a `get` method that works similarly to the `$.get` in jQuery. It expects to be provided a URL endpoint to query.

  ```js
  axios.get('https://www.omdbapi.com/?t=The%20Matrix&apikey=trilogy');
  ```

  - Similar to jQuery's `$.ajax`, an axios query returns a Promise object. More on this shortly, but for now it's important to know that we use `.then` to handle the response from the AJAX request.

  ```js
  .then(function(res) {
    console.log(res.data);
  });
  ```

- With [32-Ins_Axios-Demo/index.js] open in your IDE, run the file and demonstrate the output in your console.

- Answer any questions before the next activity.

### Students Do: 32-Stu_Axios

- 1030-40 (10 min)

### Instructor Do: Review

- 1040-45 (5 min)

  - Axios works similarly to `$.ajax` in jQuery

- Axios is a third party npm package so must be installed and required

- We can use the `Array.prototype.map` method to turn the array of repo objects into an array of strings containing the repo names.

- Similarly to asynchronous callbacks, we can nest Promises as a way to control the order of asynchronous code.

- Open [33-Stu_Axios/Solved/index.js] in your IDE and point out the following:

  - We first require all the packages we will need. We then create an inquirer prompt to gather a GitHub username from our user.

  ```js
  const fs = require('fs');
  const axios = require('axios');
  const inquirer = require('inquirer');

  inquirer.prompt({
    message: 'Enter your GitHub username:',
    name: 'username'
  });
  ```

  - By calling `axios.get` inside of the `.then` of the `inquirer.prompt`, we can ensure that `axios.get` is called _after_ a response has been provided to `inquirer.prompt`. Similarly, by calling `fs.writeFile` inside of the `.then` of `axios.get`,we can ensure that the file is only written after a response have been received from the API.

  ```js
  .then(function({ username }) {
    const queryUrl = `https://api.github.com/users/${username}/repos?per_page=100`;
    axios.get(queryUrl).then(function(res) {
  ```

  - In order to get just the repository names and not all of the JSON data, we're using the `map` method to return the repository names into the `repoNames` array.

  ```js
  const repoNames = res.data.map(function(repo) {
    return repo.name;
  });

  const repoNamesStr = repoNames.join("\n");

  fs.writeFile("repos.txt", repoNamesStr, function(err) {
    if (err) {
      throw err;
    }

    console.log(`Saved ${repoNames.length} repos`);
  ```

- Answer any questions before moving on to the next demonstration.

### Instructor Do: Introduce Promises

- 1045-50 (5 min)

Use the prompts and talking points below to demonstrate the following key point(s):

- Promises are JavaScript objects that can be used to control the flow of asynchronous code.

- We've used Promises before, mostly with jQuery's AJAX method.

  - When have we used Promises in the past?

  - When we used the jQuery `ajax` method, and when we used `axios`.

  - How are Promises _visually_ different than asynchronous callbacks?

  - Promises use a `.then` method to describe what should happen once the async code completes.

  - When using `.then`, what kind of object are we working with?

  - A promise object.

- Open [34-Ins_Introduce-Promises/index.js] in your IDE and explain the following points:

  - Node has a built-in `util` module that has a few useful utility functions.

  ```js
  const fs = require('fs');
  const util = require('util');
  ```

  - The `util.promisify` method can be used to take a function that uses a Node.js style callback and create a new version of the function that uses Promises. A Node.js style callback is a function that has a `(err, data) =>` signature. We're using the `util.promisify` method to create Promise-based versions of `fs.writeFile` and `fs.readFile`.

  ```js
  // The built-in util package can be used to create Promise-based versions of functions using node style callbacks
  const readFileAsync = util.promisify(fs.readFile);
  const writeFileAsync = util.promisify(fs.writeFile);

  readFileAsync('animals.json', 'utf8').then(function(data) {
    // Parse the JSON string to an object
    const animalJSON = JSON.parse(data);

    // Create two new arrays to contain the cats and dogs objects
    const dogs = [];
    const cats = [];

    // For each element in animal
    animalJSON.forEach(function(animal) {
      if (animal.species === 'dog') {
        dogs.push(animal);
      } else if (animal.species === 'cat') {
        cats.push(animal);
      }
    });

    // Turn the arrays into JSON strings so they can be written to files
    const dogJSON = JSON.stringify(dogs, null, 2);
    const catJSON = JSON.stringify(cats, null, 2);

    writeFileAsync('dogs.json', dogJSON).then(function() {
      console.log('Successfully wrote to dogs.json file');
    });

    writeFileAsync('cats.json', catJSON).then(function() {
      console.log('Successfully wrote to cats.json file');
    });
  });
  ```

  - Do we see any benefit to using Promises over callbacks yet?

  - Now that we've had a chance to practice writing basic Promise syntax, we're ready to go over some of the benefits of Promises over callbacks. We'll begin to see this during the review of the next activity.

### Students Do: 35-Stu-Joke-Saver

- 1050-11 (10 min)

### Instructor Do: Review

- 11-05 (5 min)

Use the prompts and talking points below to demonstrate the following key point(s):

- By nesting Promises, we can control the order in which they resolve.

- The `util.promisify` method allows us to convert a NodeJS-style callback function to a function that uses Promises instead.

- We'll need to use the `fs.appendFile` method to append text to a `txt` file, keeping in mind that each line should be separated by a newline character (`\n`).

- Open the [35-Stu-Joke-Saver/Solved/index.js] in your IDE and point out the following:

  - We first require the necessary packages.

  ```js
  const fs = require('fs');
  const util = require('util');
  const axios = require('axios');
  ```

  - We're using `utils.promisify` to create Promise-based versions of `fs.readFile` and `fs.appendFile`.

  ```js
  const appendFileAsync = util.promisify(fs.appendFile);
  const readFileAsync = util.promisify(fs.readFile);
  ```

  - We're appending the joke retrieved from the API to the `jokes.txt` file with a newline at the end. Inside of the `.then` of the `appendFileAsync` function, we're calling `readFileAsync` to read the file's contents. Since both functions run asynchronously, this is how we can ensure the file isn't read before it's been written to.

  ```js
  const config = { headers: { accept: 'application/json' } };

  axios
    .get('https://icanhazdadjoke.com/', config)
    .then(function(res) {
      const { joke } = res.data;

      appendFileAsync('jokes.txt', joke + '\n').then(function() {
        readFileAsync('jokes.txt', 'utf8').then(function(data) {
          console.log('Saved dad jokes:');
          console.log(data);
        });
      });
    })
    .catch(function(err) {
      console.error(err);
    });
  ```

  - What are the advantages of using Promises over callbacks in this example?

  - Trick question! There isn't one.

  - How are Promises more useful than callbacks?

  - So far we still aren't doing anything with Promises that we couldn't do with callbacks alone. One of the advantages of using Promises starts to become clear in the solution to the bonus activity.

Use the prompts and talking points below to demonstrate the following key point(s):

- `.then` is chainable.

- The returned value of a `.then` is available to the next `.then` call.

- If the return is an object, the next `.then` doesn't run until the previous resolved.

- Open [35-Stu-Joke-Saver/Solved/Bonus/index.js] in your IDE and explain the following:

  - The functionally of these examples is the same, but there's a key difference in the way the code is written. Promises, similar to jQuery methods, are chainable

  ```js
  axios.get('https://icanhazdadjoke.com/', config).then(function(res) {
    const { joke } = res.data;

    return appendFileAsync('jokes.txt', joke + '\n');
  });
  ```

  - Whatever is returned from the function passed into a Promise's `.then` method is available inside of the next chained Promise. If what's being returned is a Promise object itself, the next `.then` only runs when the returned Promise resolves. This is useful as it allows us to write clearer code that's easier to understand and have more control over the sequencing of async behavior.

  ```js
    .then(function() {
      return readFileAsync("jokes.txt", "utf8");
    })
    .then(function(data) {
      console.log("Saved dad jokes:");
      console.log(data);
    })
    .catch(function(err) {
      console.error(err);
    });
  ```

  - How is the code in the bonus solution arranged differently than the code in the basic solution?

  - Promises are being chained, rather than being nested inside of each other.

  - Why not just use callbacks?

  - If Promises didn't exist and we only had callback functions, we'd eventually find ourselves in what's referred to as ["callback hell"](http://callbackhell.com/). In "callback hell" our code nesting becomes so deep it's difficult to understand and we have to scroll horizontally in our editors to read everything.

- Slack out the following image to better demonstrate "callback hell":

  - Answer any remaining questions before the next activity.

### Instructor Do: 36-Ins_Promise-Constructor

- 1105-15 (10 min)

- Use the following talking points below:

  - Promise objects can be "constructed" from scratch using a JavaScript function

  - ES6 introduced native Promises to JavaScript. Before this, Promises were still used, but that functionality was provided by various third party libraries.

  - Now that Promises are built-in to JavaScript, we can more easily use Promises to wrap any asynchronous behavior.

  - The built-in Promise constructor can be used to convert a callback-based function into one using Promises, similar to what `util.promisify` can do for some types of functions.

- Open [36-Ins_Promise-Constructor/index.js] in your editor:

  - In this example we're using the Promise constructor function to create a `readFileAsync` function, essentially doing what `util.promisify` does for us. `Promise` is a special type of function known as a constructor function. We'll discuss constructor functions in-depth in the next unit, but for now, students just need to understand we call this function using the `new` keyword, and that it returns a new Promise object.

  ```js
  const fs = require("fs");

  function readFileAsync(path, encoding) {
  ```

  - The `Promise` function takes one parameter: a callback function. The callback function passed to `Promise` has two parameters of its own: a `resolve` function and a `reject` function.

  ```js
  return new Promise(function(resolve, reject) {
  ```

  - The `resolve` function is called when we're done with our async functionality if nothing went wrong. The `resolve` function can be provided arguments which will be available inside of the `.then` of the resolved Promise. The `reject` function is called if something when wrong, such as an error occurring. Anything provided as an argument to `reject` is available inside of the `.catch` of the rejected Promise.

  ```js
  fs.readFile(path, encoding, function(err, data) {
    if (err) {
      return reject(err);
    }

    resolve(data);
  ```

  - Since `readFileAsync` returns a Promise object, we can execute `readFileAsync` and then use `.then` or `.catch` from its returned value.

  ```js
  readFileAsync('example.txt', 'utf8')
    .then(function(data) {
      console.log(data);
    })
    .catch(function(err) {
      console.error(err);
    });
  ```

-  ### Students Do: 37-Stu_Promise-Constructor

- 1115-25 (10 min)

### Instructor Do: Review

- 1125-30 (5 min)

  - When constructing Promise objects, we "resolve" on success or we "reject" on failure.

- Open [37-Stu_Promise-Constructor/Solved/index.js] in your IDE and explain the following points:

  - If `seconds` isn't a number or is a number less than 1, we `reject` an error that will be available in the Promise's `.catch`.

  ```js
  function waitFor(seconds) {
    return new Promise(function(resolve, reject) {
      if (isNaN(seconds) || seconds < 1) {
        return reject(Error("Parameter 'seconds' must be a positive number!"));
      }
  ```

  - When the timeout completes, we call the `resolve` function. Optionally we can pass arguments into `resolve` that will be available in the Promise's `.then`.

  ```js
  setTimeout(function() {
    resolve('Success!');
  }, seconds * 1000);
  ```

  - We can then invoke our `waitFor()` function.

  ```js
  waitFor(2)
    .then(function(msg) {
      console.log(msg);
    })
    .catch(function(err) {
      console.error(err);
    });
  ```

- Answer any remaining questions before the next activity.

### Instructor Do: Introduce Async/Await

- 1130-40 (10 min)

  - ES2017 introduced an alternative syntax for Promises called async/await.

- Async/await is "sugar-syntax" for Promises, and allows us to write asynchronous code that looks synchronous, which can be easier to understand.

- Async/await is used with functions and methods that return Promise objects.

- Code using the `await` syntax must be inside of a function declared with the `async` identifier.

- Typically `try/catch` is used with `async/await`.

- What do we think is easier? Writing functions with Promises? Or writing functions with callbacks? Which one do we have to know more to use?

- Promises look nicer than callbacks, but we have to write and understand more code to use them.

- If JavaScript is single-threaded, why create this asynchronous functionality?

- For many developers, Promises aren't the most intuitive way to handle asynchronous behavior, especially for those coming from other programming languages. As the number of web developers increases, ideas found in other languages often make their way into JavaScript.

- Have any new "asynch" features been added?

- The ES2017 JavaScript update gave us a feature found in C#: **async/await**. In JavaScript, async/await uses Promises under the hood, but allows us to write asynchronous code in a way that _looks_ synchronous.

- Why is `async/await` considered "sugar-syntax"?

- Sugar-syntax is any aspect of the syntax a programming language that makes it easier to read, write, or understand. As an example, the `x += 1` is sugar-syntax for `x = x + 1`. As a result, code written with async/await is often easier to read, write, and understand.

- Open the example in [38-Ins_Async-Await/index.js] in your editor:

  - Async/await is used with functions and methods that return Promise objects such as `axios.get` and `inquirer.prompt`.

  ```js
  const axios = require('axios');
  const inquirer = require('inquirer');

  getMovie();
  ```

  - Code using the `await` syntax must be inside of a function declared with the `async` identifier. We typically use `try/catch` blocks to catch errors when using async/await, though the `.catch` method can still be used since we're still working with Promises.

  ```js
  async function getMovie() {
    try {
  ```

  - Using the `await` keyword, we can assign the result of a Promise-based function to a variable.

  ```js
  const { movie } = await inquirer.prompt({
    message: "Search a movie:",
    name: "movie"
  });

  const { data } = await axios.get(
    `https://www.omdbapi.com/?t=${movie}&apikey=trilogy`
  );

  console.log(data);

  } catch (err) {
    console.error(err);
  }
  ```

- Answer any questions before moving on to the next activity.

### Students Do: 39-Stu_Async-Await

- 1140-55 (15 min)

### Instructor Do: Review

- 1155-1205 (10 min)

  - Using async/await, we can write asynchronous code that looks synchronous

- async/await is sugar syntax for Promises, meaning Promises are still used under the hood

- Open [39-Stu_Async-Await/Solved/index.js] in your editor:

  - Code using the `await` syntax must be inside of a function declared with the `async` identifier.

  ```js
  async function combineAnimals() {
    try {
  ```

  - We can `await` reading from each file one at a time. This is equivalent to chaining Promise functions in sequence.

  ```js
  const hamster = await readFileAsync('hamster.json', 'utf8');
  const dog = await readFileAsync('dog.json', 'utf8');
  const cat = await readFileAsync('cat.json', 'utf8');
  const goldfish = await readFileAsync('goldfish.json', 'utf8');
  ```

  - Since data read from a file comes in as a string, we need to parse the strings to JSON to work with them. We use `try/catch` blocks to handle any errors that may occur.

  ```js
      const animalJSON = [hamster, dog, cat, goldfish].map(JSON.parse);

      await writeFileAsync(
        "combined.json",
        JSON.stringify(animalJSON, null, 2),
        "utf8"
      );
      console.log("Successfully wrote to 'combined.json' file");
    } catch (err) {
      console.error(err);
    }
  }

  combineAnimals();
  ```

### BREAK

- 1205-45 (40 min)

### Instructor Do: Introduce Mini Project

- 1245-50 (5 min)

- Run the mini-project solution found in [40-Stu_Mini-Project/Solved/Bonus/index.js] without demonstrating any of the code.

- Answer any questions students may have about the intended functionality of this completed activity.

### Students Do: 40-Stu_Mini-Project

- 1250-150 (60 min)

### Instructor Do: Review

- 150-2 (10 min)

  - We can construct an HTML string using string template literals

- We can use Promises or the async/await syntax to control the flow of asynchronous code

- Open [40-Stu_Mini-Project/Solved/Basic/index.js] in your IDE and point out the following:

  - First we require the necessary packages.

  ```js
  const inquirer = require('inquirer');
  const fs = require('fs');
  const util = require('util');
  ```

  - We use the `util.promisify` method to take a function that uses Node style callbacks to create a new version of the function that now uses Promises.

  ```js
  const writeFileAsync = util.promisify(fs.writeFile);
  ```

  - We prompt the user for their basic information using `inquirer.prompt`.

  ```js
  function promptUser() {
    return inquirer.prompt([
      {
        type: 'input',
        name: 'name',
        message: 'What is your name?'
      },
      {
        type: 'input',
        name: 'location',
        message: 'Where are you from?'
      },
      {
        type: 'input',
        name: 'hobby',
        message: 'What is your favorite hobby?'
      },
      {
        type: 'input',
        name: 'food',
        message: 'What is your favorite food?'
      },
      {
        type: 'input',
        name: 'github',
        message: 'Enter your GitHub Username'
      },
      {
        type: 'input',
        name: 'linkedin',
        message: 'Enter your LinkedIn URL.'
      }
    ]);
  }
  ```

  - We create a function named `generateHTML` that returns a `template literal` which in this case is just an HTML document. Within this template literal we can insert the responses we gathered from our user via inquirer.

  ```js
  function generateHTML(answers) {
    return `
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css">
    <title>Document</title>
  </head>
  <body>
    <div class="jumbotron jumbotron-fluid">
    <div class="container">
      <h1 class="display-4">Hi! My name is ${answers.name}</h1>
      <p class="lead">I am from ${answers.location}.</p>
      <h3>Example heading <span class="badge badge-secondary">Contact Me</span></h3>
      <ul class="list-group">
        <li class="list-group-item">My GitHub username is ${answers.github}</li>
        <li class="list-group-item">LinkedIn: ${answers.linkedin}</li>
      </ul>
    </div>
  </div>
  </body>
  </html>`;
  }
  ```

  - Finally we call our `promptUser` function and on success we generate our HTML file with this customized responses. We then create the file, appending the contents of the HTML template literal we created.

  ```js
  promptUser()
    .then(function(answers) {
      const html = generateHTML(answers);

      return writeFileAsync('index.html', html);
    })
    .then(function() {
      console.log('Successfully wrote to index.html');
    })
    .catch(function(err) {
      console.error(err);
    });
  ```

- Answer any high-level questions before demonstrating the bonus solution using async/await.

- Open [40-Stu_Mini-Project/Solved/Bonus/index.js] in your IDE and point out the following differences:

  - Code using the `await` syntax must be inside of a function declared with the `async` identifier. We're also using a `try/catch` block to handle any errors that may occur when using async/await.

  ```js
  async function init() {
  console.log("hi")
  try {
    const answers = await promptUser();

    const html = generateHTML(answers);

    await writeFileAsync("index.html", html);

    console.log("Successfully wrote to index.html");
  } catch(err) {
    console.error(err);
  }
  ```

  - So, how can asynchronous code help developers write better code.

  - Asynchronous programming allows our code to execute logic without blocking the rest of the applications functionality.
