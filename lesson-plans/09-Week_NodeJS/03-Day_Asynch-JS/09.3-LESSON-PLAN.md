# Lesson Plan: Asynchronous JavaScript

## Overview

In this lesson, we will review callback functions and introduce Promises and async/await.

## Learning Objectives

- Describe three approaches for handling asynchronous behavior with JavaScript

- Utilize the axios library to perform AJAX requests

- Chain Promises together to perform asynchronous operations in sequence

- Utilize the Promise constructor to wrap asynchronous behavior in Promise objects.

- Utilize async/await syntax to write asynchronous code

### Instructor Do: Preview

- 10-1010 (10 min)

  - The focus of today will be all things async.

  - We'll dive deep into asynchronous callback functions, as well as Promises, special objects used in JavaScript handling asynchronous behavior.

  - What are some examples of asynchronous behavior we've encountered so far with JavaScript?

    - Making AJAX requests, timers, responding to browser events such as clicks, reading/writing to the filesystem.

  - Why do we write "asynchronous" code?

    - Since the JavaScript runtime is single-threaded, we need to write asynchronous code effectively in order to avoid blocking client requests on the server.

- Demo [40-Stu_Mini-Project/Solved/Bonus/index.js]

  - very similar to upcoming HW

### Students Do: 31-Stu_Callback-Review

- 1010-20 (10 min)

- read from a file and create two new files

### Instructor Do: Review

- 1020-25 (5 min)

  - Are callback functions synchronous?

    - Callback functions themselves aren't asynchronous any more than regular named functions are.

  - Do we have to wait on callbacks?

### Instructor Do: 32-Ins_Axios-Demo

- 1025-30 (5 min)

  - Axios works similarly to `$.ajax` in jQuery or `fetch` in ES6

  - `fetch` is not available in the node runtime since it is not part of ECMA, instead it's part of the web platform API defined by WHATWG and W3C and implemented by the runtime (browser)

- When writing server-side code, can we use jQuery?

  - No, jQuery is a front-end library. It depends on certain browser APIs that don't exist in a node context.

- write code by hand

  - `const axios = require('axios');`

  - run the code - it will fail

  - `npm install axios --save` (make sure you already have a package.json)

  ```js
  axios
    .get('https://www.omdbapi.com/?t=The%20Matrix&apikey=trilogy')
    .then(res => console.log(res.data));
  ```

### Students Do: 32-Stu_Axios

- 1030-40 (10 min)

- use axios to get list of repos from user's github and output to a text file

### Instructor Do: Review

- 1040-45 (5 min)

- notice there are nested promises
  - what would happen if I pulled out `axios.get`?

### Instructor Do: 34-Ins_Introduce-Promises

- 1045-50 (5 min)

- Promises are JavaScript objects that can be used to control the flow of asynchronous code.

- When have we used Promises in the past?

  - `ajax`, `axios` and `fetch`

- Promises have a `.then` method which with a callaback function as a parameter

- Node has a built-in `util` module that has a few useful utility functions.

- `util.promisfy` converts a method which uses Node.js style callback (`(err, data) =>`) and creates a Promise

  - we're going to go over some of the benefits of promises vs callbacks in the next activity

### Students Do: 35-Stu-Joke-Saver

- 1050-11 (10 min)

- get dad jokes using promises

### Instructor Do: Review

- 11-05 (5 min)

- Start with nested basic example

- What are the advantages of using Promises over callbacks in this example?

  - Trick question! There isn't one.

  - How are Promises more useful than callbacks?

  - So far we still aren't doing anything with Promises that we couldn't do with callbacks alone. One of the advantages of using Promises starts to become clear in the solution to the bonus activity.

- show bonus with promise chaining

  - `.then` is chainable.

  - The returned value of a `.then` is available to the next `.then` call

  - Whatever is returned from the function passed into a Promise's `.then` method is available inside of the next chained Promise. If what's being returned is a Promise object itself, the next `.then` only runs when the returned Promise resolves. This is useful as it allows us to write clearer code that's easier to understand and have more control over the sequencing of async behavior.

  - Why not just use callbacks?

    - If Promises didn't exist and we only had callback functions, we'd eventually find ourselves in what's referred to as ["callback hell"](http://callbackhell.com/). In "callback hell" our code nesting becomes so deep it's difficult to understand and we have to scroll horizontally in our editors to read everything.

### Instructor Do: 36-Ins_Promise-Constructor

- 1105-15 (10 min)

  - creates a promise directly, similar to `util.promisify`

  - promises became native to JavaScript with ES6

  - special function called a constructor - discussed more next unit

  - `new` keywords creates a new instance of a class - discussed more next unit

  - `resolve` is when we succeed and we can pass in arguments to have available to the callback function as `.then`

  - `reject` is when we fail. Available in `.catch`

- ### Students Do: 37-Stu_Promise-Constructor

- 1115-25 (10 min)

- convert from Node.js callbacks to promises

### Instructor Do: Review

- 1125-30 (5 min)

  ### Instructor Do: 38-Ins_Async-Await

- 1130-40 (10 min)

  - ES2017 introduced an alternative syntax for Promises called async/await.

- Async/await is "sugar-syntax" for Promises, and allows us to write asynchronous code that looks synchronous, which can be easier to understand.

  - This idea came from other languages (for example, C#). Language ideas tend to spread if they're good.

- Async/await is used with functions and methods that return Promise objects

- Code using the `await` syntax must be inside of a function declared with the `async` identifier

- Typically `try/catch` is used with `async/await`

- Promises are more explicit with what is needed but are pretty code heavy

- If JavaScript is single-threaded, why create this asynchronous functionality?

### Students Do: 39-Stu_Async-Await

- 1140-55 (15 min)

- convert previous promise based activity to async/await

### Instructor Do: Review

- 1155-1205 (10 min)

  - Using async/await, we can write asynchronous code that looks synchronous

- async/await is sugar syntax for Promises, meaning Promises are still used under the hood

- Open [39-Stu_Async-Await/Solved/index.js] in your editor:

  - Code using the `await` syntax must be inside of a function declared with the `async` identifier.

  ```js
  async function combineAnimals() {
    try {
  ```

  - We can `await` reading from each file one at a time. This is equivalent to chaining Promise functions in sequence.

  ```js
  const hamster = await readFileAsync('hamster.json', 'utf8');
  const dog = await readFileAsync('dog.json', 'utf8');
  const cat = await readFileAsync('cat.json', 'utf8');
  const goldfish = await readFileAsync('goldfish.json', 'utf8');
  ```

  - Since data read from a file comes in as a string, we need to parse the strings to JSON to work with them. We use `try/catch` blocks to handle any errors that may occur.

  ```js
      const animalJSON = [hamster, dog, cat, goldfish].map(JSON.parse);

      await writeFileAsync(
        "combined.json",
        JSON.stringify(animalJSON, null, 2),
        "utf8"
      );
      console.log("Successfully wrote to 'combined.json' file");
    } catch (err) {
      console.error(err);
    }
  }

  combineAnimals();
  ```

### BREAK

- 1205-45 (40 min)

### Instructor Do: Introduce Mini Project

- 1245-50 (5 min)

- Run the mini-project solution found in [40-Stu_Mini-Project/Solved/Bonus/index.js] without demonstrating any of the code.

- Answer any questions students may have about the intended functionality of this completed activity.

### Students Do: 40-Stu_Mini-Project

- 1250-150 (60 min)

### Instructor Do: Review

- 150-2 (10 min)

  - We can construct an HTML string using string template literals

- We can use Promises or the async/await syntax to control the flow of asynchronous code

- Open [40-Stu_Mini-Project/Solved/Basic/index.js] in your IDE and point out the following:

  - First we require the necessary packages.

  ```js
  const inquirer = require('inquirer');
  const fs = require('fs');
  const util = require('util');
  ```

  - We use the `util.promisify` method to take a function that uses Node style callbacks to create a new version of the function that now uses Promises.

  ```js
  const writeFileAsync = util.promisify(fs.writeFile);
  ```

  - We prompt the user for their basic information using `inquirer.prompt`.

  ```js
  function promptUser() {
    return inquirer.prompt([
      {
        type: 'input',
        name: 'name',
        message: 'What is your name?'
      },
      {
        type: 'input',
        name: 'location',
        message: 'Where are you from?'
      },
      {
        type: 'input',
        name: 'hobby',
        message: 'What is your favorite hobby?'
      },
      {
        type: 'input',
        name: 'food',
        message: 'What is your favorite food?'
      },
      {
        type: 'input',
        name: 'github',
        message: 'Enter your GitHub Username'
      },
      {
        type: 'input',
        name: 'linkedin',
        message: 'Enter your LinkedIn URL.'
      }
    ]);
  }
  ```

  - We create a function named `generateHTML` that returns a `template literal` which in this case is just an HTML document. Within this template literal we can insert the responses we gathered from our user via inquirer.

  ```js
  function generateHTML(answers) {
    return `
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css">
    <title>Document</title>
  </head>
  <body>
    <div class="jumbotron jumbotron-fluid">
    <div class="container">
      <h1 class="display-4">Hi! My name is ${answers.name}</h1>
      <p class="lead">I am from ${answers.location}.</p>
      <h3>Example heading <span class="badge badge-secondary">Contact Me</span></h3>
      <ul class="list-group">
        <li class="list-group-item">My GitHub username is ${answers.github}</li>
        <li class="list-group-item">LinkedIn: ${answers.linkedin}</li>
      </ul>
    </div>
  </div>
  </body>
  </html>`;
  }
  ```

  - Finally we call our `promptUser` function and on success we generate our HTML file with this customized responses. We then create the file, appending the contents of the HTML template literal we created.

  ```js
  promptUser()
    .then(function(answers) {
      const html = generateHTML(answers);

      return writeFileAsync('index.html', html);
    })
    .then(function() {
      console.log('Successfully wrote to index.html');
    })
    .catch(function(err) {
      console.error(err);
    });
  ```

- Answer any high-level questions before demonstrating the bonus solution using async/await.

- Open [40-Stu_Mini-Project/Solved/Bonus/index.js] in your IDE and point out the following differences:

  - Code using the `await` syntax must be inside of a function declared with the `async` identifier. We're also using a `try/catch` block to handle any errors that may occur when using async/await.

  ```js
  async function init() {
  console.log("hi")
  try {
    const answers = await promptUser();

    const html = generateHTML(answers);

    await writeFileAsync("index.html", html);

    console.log("Successfully wrote to index.html");
  } catch(err) {
    console.error(err);
  }
  ```

  - So, how can asynchronous code help developers write better code.

  - Asynchronous programming allows our code to execute logic without blocking the rest of the applications functionality.
