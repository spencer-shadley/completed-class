# 9.2 - Node and ES6 Day 2

## Overview

TODO: include fetch

In this class, we will be building on students' proficiency with Node by introducing them to additional ES6 features that they will be using in Node.

## Instructor Notes

## Learning Objectives

- Identify and implement how and when to use arrow functions
- Identify and implement how and when to use let and const variables
- Identify and destructuring of arrays, functions and objects in ES6
- Identify and implement how and when to use template literals
- Identify and apply for...of loops
- Identify and implement rest and spread syntax
- Identify and apply array methods forEach, filter and map

### Instructor Do: 16-Ins_ArrowFunction

- 630-40 (10 min)

- Explain ES6 is an update to ECMAScript which is what JS is based on

  - QWERTY is a layout standard for keyboards
  - ECMA is a standard. JavaScript is written to comply to the ECMA standard with some additions.
  - JavaScript engines are created for each browser (V8 in Chrome and Node, SpiderMonkey in FF)

    - the engine knows how to actually perform the capabilities in the specification.
    - multiple engines may know how to "jump" but one may implement it more efficiently
    - JavaScript runtime is the system running the engine (in a browser there is a window object)

  - https://caniuse.com/#search=es6

    - Intl.PluralRules API (no safari)
    - WebXR Device API (only chrome)

  - demo arrow functions - write `01-syntax` by hand

- Now walk through the first part of the code in [02-context.js].

  - `setTimeout` changes the context in which it is being run. `this` stops referring to `person`

  - need to bind `this` using an arrow function

    - arrow functions automatically bind to the context or object it's created inside of even if it's not a property of that object

    - arrow functions inherit `this` from the context in which they're created

  - I help people a lot with this binding issue

  - we could resolve this issue by using `.bind(this)`

- [03-arrow-property-methods.js]

  - arrow functions bind to window scope in object declaration

  - generally use arrow functions with the exception of properties on an object

  - arrow functions are also missing `bind`, `call` and `apply` (methods on the Function proto)

- ### Student Do: 17-Stu_ArrowFunctionPractice

- 640-50 (10 min)

- In this activity students will convert a file with pre-written code over to use arrow functions where suitable.

- Students won't need to fully understand how all the code in this activity works, just the rules we've established about when arrow functions should and shouldn't be used.

### Instructor Do: Review

- 650-55 (5 min)

- Open [Arrow Function Practice] in your editor and run the code.

- Point out that even though we've converted a few of the examples over to use arrow functions, the code works exactly the same as it did before.

- Point out again how we can omit the parentheses around the arrow function parameters if there is only one. This **does not** work if the arrow function has multiple or no parameters. This is optional, assure students that they don't need to do this, but may see code written this way.

  - Point out again how we can also omit an arrow function's curly braces if the arrow function body only contains one expression. The single expression is automatically returned from the function when we use this shorter syntax. Students may see code written in this way, but this is also optional, if students prefer, they may continue to use curly braces and the `return` keyword.

- Finally point out the `netflixQueue` object. Ask the class: Why didn't we convert the functions here to arrow functions?

  - Whenever we're working with objects, we usually don't want to write its methods as arrow functions since `this` inside of the arrow function will refer to whatever object the one we're defining is inside of (usually the `window` in the browser or `module.exports` in node).

- Inform the class that the key takeaways for now are:

  - In most cases, we can replace regular functions with arrow functions.

  - Arrow functions shouldn’t be object methods.

### Instructor Do: Let and Block Scope

- 655-705 (10 min)

- In this example we will demonstrate the new `let` keyword and how block scoping works.

- Explain to the class that by now they should be familiar with function scope. Have a volunteer offer up their explanation for what this means.

- With function scope, variables defined inside of a function body are only available inside of that function, as well as functions defined inside of that function.

- Explain that ES6 offers us a new way to define variables using `let`. Unlike `var`, `let` is block scoped.

- Inform the class that a "block" is created whenever we have a pair of curly braces. This includes loops and conditional statements as well as function bodies. Since `let` is block scoped, any variables we define using `let` inside of a block are only available inside of that block.

- This can help us avoid a few silly mistakes in our code.

- Point out the first example in [Let Block Scope].

* Point out how our for-loop counter continues to exist after the for-loop has ended. We don’t need it anymore. This could potentially cause issues if we wanted to refer to a different variable with the same name as the counter later.

* Even though the `let` declaration is not technically inside of the curly braces, it's considered to be part of the block anyway in this case.

* Point out how the counter no longer exists after the loop is done when we use `let`.

- Point out how when using `let`, any values defined inside of a conditional block no longer exist outside of the conditional.

- If you need to use a variable both inside and outside of a block, you’d define it outside of the block. Example:

  ```js
  let favoriteFood;

  if (true) {
    favoriteFood = 'pizza';
  }

  // This works since favoriteFood is not defined inside of a block
  console.log(favoriteFood);
  // Prints `pizza`
  ```

- This helps express intent because it tells others more information about where or how we’ll be using the value.

- Inform the class that going forward, we will no longer be using `var`.

- Unlike arrow functions and regular functions, we can completely replace `var` with `let`.

- ### Instructor Do: Constant Reference

- 705-15 (10 min)

- In this demonstration we will cover the new `const` keyword for defining variables and when it should be used.

- Explain to the class that while we can replace all the `var`s in all of our code with `let`, we also have one more new option for declaring variables: `const`.

- Ask the class: Can anyone tell me what they think `const` is used for in JavaScript?

  - Odds are, if any students have been exposed to another programming language, someone will answer that `const` is like `let`, except that it's for variables which can't be changed. This is _mostly_ true.

- Explain that `const` has the same rules as `let` for block scoping. There is, however, one one key difference between `const` and `let`: a variable declared with `const` cannot be _reassigned_.

- Inform the class that using `const` can help prevent us from accidentally reassigning values we don't mean to, and also helps express intent, helping us document important values in our code for other developers, or for our future selves when we forget how the code works.

- Open [Constant Reference] and go through each example.

* Point out that whenever we try to reassign a variable declared with `const`, we get an error in the console.

* Whenever we're working with primitive types such as strings or numbers, even modifying the value e.g. `age++`, is considered to be reassigning it.

* This is because primitive types such as numbers and strings are "passed by value", i.e. a new value is created and referred to in memory anytime we modify variable containing a primitive type.

- Point out how in the second example, we can update the array and object as long as we aren't reassigning them completely, i.e. using the `=` operator to assign the variables a new values.

- Explain that `const` in JavaScript doesn't mean "constant value", but rather "constant reference". Because arrays and objects are non-primitive values, they are "passed by reference", i.e. modifying an array or object doesn't create a new object or array in memory. This is why we can push to the array or update the object's properties.

  - To check for understanding, ask the class: `Why isn't this last example allowed?`

    - While we can modify arrays and objects declared with `const`, we still can't reassign them completely.

- Key takeaways for this demonstration:

  - Both `const` and `let` are block scoped.

  - Use `let` whenever a value will need to be reassigned.

  - Use `const` whenever a value won't need to be reassigned.

### Student Do: Convert Const Let Arrow

- 715-25 (10 min)

- In this activity students will convert a prebuilt Crystal Guessing Game to use the new ES6 syntax covered so far.

- Stress that students don't need to completely understand all of the code in the activity. They just need to remember what we just overed about `const`, `let`, and arrow functions.

### Instructor Do: Review Convert Const Let Arrow

- 725-30 (5 min)

- Open [Solved/index.js] in your code editor and walk through the code with the class.

- For every `let`, ask the class: "Why it isn't a `const` instead?"

  - Because the value is reassigned somewhere.

- For every `function` keyword: ask the class, "Why isn't an arrow function isn't used instead?"

  - In this activity, constructor functions and functions that are object methods using the `this` keyword are kept as regular functions.

  - For object methods, arrow functions will prevent `this` from binding to the object.

  - Arrow function's can't be used as constructor functions.

- Run the application in the browser and demonstrate that it works the same as it did before.

- Answer any remaining questions about the solution.

### Instructor Do: Functional Loops

- 730-40 (10 min)

- In this demonstration students will be introduced to new Array methods `forEach`, `filter`, and `map`.

- Explain that `filter` and `map` are used heavily in React when rendering elements from array data. Students have probably seen `forEach` already, but it's a good stepping stone for understanding `filter` and `map`.

- Go through each example in [index.js] one at a time to demonstrate the utility of `forEach`, `filter`, and `map`.

- Explain how each of the array methods:

  - Works on an array

  - Runs a callback function once for each element in the array

  - Passes the each element into the callback as an argument

- Then work on explaining the differences between each of these methods:

  - `forEach` is the simplest. It runs the callback for each element in the array

  - `fitler` is similar to `forEach`, but it returns a brand new array using elements in the original array. If an element's callback function returns a truthy value, it is added to the newly returned array, otherwise it is _filtered_ out and doesn't get added to the new array.

  - `map` is similar in that it also returns a brand new array using elements in the original array. Unlike `filter`, the new array created with `map` is always the same length as the original array. Whatever is returned by the callback on each iteration is what goes into the new array. We can use this to create a new array of modified elements, or elements computed from values in the original array.

- Run each example one at a time and demonstrate the logged output for students.

- If helpful, demonstrate how each piece of functionality can be achieved (with more code) using for-loops.

### Student Do: Functional Loops

- 740-50 (10 min)

- In this activity students will use the `map` and `filter` methods to solve problems they previously would have used for-loops for.

- Consider live-coding each problem piece by piece over the duration of the activity.

### Instructor Do: Review Functional Loops

- 750-55 (5 min)

- Once time's up, open the [activity solution] and go over the code.

- Start by demonstrating the `map` example.

  - Remind the class that the callback is run once for each element in the array. Whatever it returns is what goes into the corresponding index of the new array.

  - If the arrow function syntax is still confusing, refactor the solutions to use regular functions instead.

- Then move on to the `filter` example.

numbers (`primeArray`)
const primeArray = originalArray.filter(isPrime);

larger than 5(`moreThan5Array`)

const moreThan5Array = originalArray.filter(num => num > 5);

- Point out that we don't need to pass an anonymous function into the `map` and `filter` methods - we can write a named function and use that instead, as is the case for `isPrime`.

- Remind the class that if the function returns something truthy, that array element is copied to the new array, otherwise it is skipped.

  - The first example should contain an array of only prime numbers, the second should only contain numbers larger than `5`.

- Once again, refactor the solution to regular functions if arrow functions are still a point of confusion.

- Check for understanding by asking questions such as:

- "When's a time in real life when you need to _filter_ through something?"

  - When looking for a word in the dictionary, you're _filtering_ out all the words that don't contain the same letters as the one you're looking for.

  - When shopping for pants, you're _filtering_ out all the ones on the rack that aren't your size.

  - When you're looking for your friend in a crowd, you're _filtering_ out everyone that doesn't look like them.

- "When's a time in real life when you need to _map_ over something?"

  - When you're _mapping_ through your todolist and marking off all the things you've completed for the day.

  - When you're _mapping_ through your laundry pile, categorizing your clothes so you can put them into the correct drawers.

- Explain that just like how we need to map and filter over things in real life, we often need to in code as well.

- ### BREAK

- 755-810

- (15 min)

### Instructor Do: Template Literals Demo

- 810-15 (5 min)

* Students will now be introducted to template literals, a new feature in ES6.

* Explain that a template literal is a special type of string that lets you create complex strings more easily and more efficiently.

* Using template literals, you can create multi-line strings and use string interpolation.

* Demo the following code in [10-Ins_Template_Literals/index.js]

- Point out that template literals use backticks ` (``) `, not quotes (' or "), to wrap the string.

- Also point out that we created a multiline string without using `\n`.

### Student Do: Template Literals

- 815-25 (10 min)

### Instructor Do: Review Template Literals

- 825-30 (5 min)

- Open [Solved/index.js] and review the code.

- Let students know that they will get a lot more practice moving forward, the biggest takeaway is to know that you have this tool available to you.

### Instructor Do: For...Of Demo

- 830-35 (5 min)

- Students will now be introduced to the For...Of syntax provided in ES6.

- There are many ways to iterate in JS but the real power of for...in is the flexibility it provides.

- Explain that the for...of statement creates a loop iterating over objects, including Array, Map, Set, String, TypedArray.

- In comparison, the `forEach` method which students are familiar with only works with arrays.

- Walk students through some common use cases in your console.

- Explain that the for...in loop is very flexible and we will continue to learn about it's use cases as we progress through the course.

### Student Do: For...Of

- 835-45 (10 min)

### Instructor Do: Review For...Of

- 845-50 (5 min)

- Review the previous activity.

- If time permits, feel free to expand and show other use cases for `for...of`.

- They syntax is relatively straightforward, the key takeaway is knowing when to use and and what to use it for.

### Instructor Do: Rest and Spread Demo

- 850-55 (5 min)

- Students will now be introduced to the spread and rest syntax available in ES6.

- Open [12-Ins_Spread_and_Rest/index.js] and step through the code.

#### Rest Parameters

- Explain that the rest parameter collects all remaining elements into an array.

- Be sure to point out that a rest paramter has to be the last argument in an array.

```js
function add(x, y) {
  return x + y;
}

console.log(add(1, 2, 3, 4, 5)); // => 3
```

- Ask the class why they think the `add` function returned 3?

- Explain that although it is possible to call a function with any number of arguments, only the fist two arguments will be counted.

- Let's rewrite this function using a rest operator.

```js
function add(...nums) {
  let sum = 0;
  for (let num of nums) sum += num;
  return sum;
}

add(1); // => 1
add(3, 3); // => 6
add(1, 1, 4, 5); // => 11
```

- In this example, we use a rest operator to collect all of the arguments into a `nums` array, giving us the ability to pass in as many arguments as we want.

- Let's try another one.

```js
function howManyArgs(...args) {
  return `You passed ${args.length} arguments.`; // point out the template literal
}

console.log(howManyArgs(0, 1)); // You have passed 2 arguments.
console.log(howManyArgs('argument!', null, ['one', 2, 'three'], 4)); // You have passed 4 arguments.
```

- The takeaway here is these variables are now available in an array inside our function, we can also pass in as many as we want.

#### Spread Operator

- The spread operator allows iterables such as arrays, objects and strings to be expanded into single arguments or elements.

- Run the following example for students.

```js
// Spread Operator

let dragons = ['Drogon', 'Viserion', 'Rhaegal'];
let weapons = ['dragonglass', ...dragons, 'wildfire']; // notice the spread operator ...dragons

console.log(weapons); // prints ["dragonglass", "Drogon", "Viserion", "Rhaegal", "wildfire"]
```

- Here you can see that we have expanded both arrays into a new array with all of the elements.

- Explain that there are a lot of use cases for rest and spread and they will continue to get more practice with them as the progress in the course.

- Take any clarifying questions before moving on.

### Student Do: Rest and Spread Syntax

- 855-905 (10 min)

### Instructor Do: Review Rest and Spread Syntax

- 905-10 (5 min)

- Open [Solved/index.js] and step through the code.

- This first part is relatively straightforeward, but check for understanding to see if there are any hangups for students.

```js
const songs = ['Creep', 'Everlong', 'Bulls On Parade', 'Song 2', 'What I Got'];
const new_songs = [...songs];

console.log(new_songs); // => ["Creep", "Everlong", "Bulls On Parade", "Song 2", "What I Got"];
```

- This one might have been a little tricky for students. There is a chance that they have not seen `reduce` before, so take a second to explain what it does. A

- Let students know that it's very common to be introduced to new methods, functions and concepts on the job and they should embrace the uncertainty of new material.

```js
// unsolved version
function addition(x, y, z) {
  const array = [x, y, z];
  return array.reduce((a, b) => a + b, 0);
}
console.log(addition(1, 2, 3)); // 6

// solved using rest
function addition(...array) {
  return array.reduce((a, b) => a + b, 0); // you don't have to change this line of code but look up reduce if you're not sure what it does here https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce
}
console.log(addition(1, 2, 3)); // 6
console.log(addition(1, 2, 3, 4, 100)); // 110
```

- There is a good chance that students will be confused on where spread and operators go, since they are very similar and can be used in similar situations.

- Let them know that this is just an introduction and they will begin to pick up fluency as they get more practice.

- Take any remaining questions before moving on.

### Instructor Do: Object Destructuring

- 910-20 (10 min)

- In this example, students will be introduced to the ES6 object destructuring syntax.

- Explain that object destructuring is a way for us to pull properties off of an object an onto separate variables for easier access. We can achieve this without ES6, but now we have a newer shorthand for doing so.

- Go through each example inside of [index.js].

  - Highlight how we can destructure multiple object properties at once, saving us a few lines of code.

  - Demonstrate how this is also possible with function parameters. This allows us to have named function parameters i.e. if we passed multiple values into a function one at a time, we'd need them to be passed in the specific order intended. Now we can simply expect an object and pull the properties off without worrying about the order they're passed in or write extra code to destructure them the old way.

### Student Do: Object Destructuring

- 920-30 (10 min)

### Instructor Do: Review Object Destructuring

- 930-35 (5 min)

- Open [Solved/index.js] in your editor and walk students through the solved exercise.
