# 10.1 - Hard Hat Zone: Constructors at Work (6:30 PM)

## Overview

In this class we will be introducing students to the usage of JavaScript constructors and how they can be used to dynamically create objects with similar schemas.

### Instructor Do: Slide deck

- 630-35 (10 min)

### Students Do: 01-Stu_Cats-And-Dogs

- 635-50 (10 min)

- object refresher - raining cats and dogs

### Instructor Do: Review

- 650-55 (5 min)

### Instructor Do: 02-Ins_Cats-And-Dogs-Constructors

- 655-705 (10 min)

- what do you see which is different from the previous activity?

  - constructor function is capitalized and can take in parameters

  - the `new` keyword creates an instance of that `class` (new to ES6)

  - we don't have an explicit `return` in the function - `new` handles this

  - noun = object, generalized = class

  - verb = function

  - verb performed by a noun = method

    - a dog barks -> dog = noun/object; bark = verb/method

    - common properties between instances/nouns = class (animal)

- show how to make named parameters

  ```js
  function Animal2({ raining, noise }) {
    this.raining = raining;
    this.noise = noise;
    this.makeNoise = () => {
      console.log(this.noise);
    };
  }
  const cow = new Animal2({ raining: true, noise: 'moo' });
  cow.makeNoise();
  ```

- Constructors enable greater flexibility. We can share similar code from a single blueprint.

### Student Do: 03-Stu_Mini-Bank

- 705-25 (20 min)

### Instructor Do: Review

- 725-35 (10 min)

### Student Do: Weather Admin

- 735-50 (15 min)

- Direct students to the next activity located in [04-Stu_Weather-Admin/Unsolved].

### Instructor Do: Review

- (10 min)

  - NPM packages are brought in with `require`.

  - `process.argv` allows us to grab CLI arguments.

- Open [04-Stu_Weather-Admin/Solved] in your IDE and explain the following to students:

  - First we require the npm package `weather-js`.

  ```js
  const weather = require('weather-js');
  ```

  - We create a constructor function called UserSearch that will take a `name` and `location` as arguments. It will also use `Date.now();` to get the current date.

  ```js
  const UserSearch = function(name, location) {
  this.name = name;
  this.location = location;
  this.date = Date.now();
  ```

  - Our constructor also has a method of `getWeather`. It will make use of the `weather-js` search function to search for weather of a given location. Lastly, we export our `UserSearch` constructor.

  ```js
  this.getWeather = function() {
    weather.find({ search: this.location, degreeType: "F" }, function(err, result) {
      if (err) {
        console.error(err);
      }
      console.log(JSON.stringify(result, null, 2));
      });
    };
  };

  module.exports = UserSearch;
  ```

- Open [04-Stu_Weather-Admin/Solved/WeatherAdmin.js] in your IDE and explain the following points:

  - First we require all the pieces necessary. `fs` is the File System, allowing us to create, delete, or update files on a users local machine. `UserSearch` is our constructor function we exported from `UserSearch.js`. Finally, we import `moment`, an NPM package for dates and times.

  ```js
  var fs = require('fs');
  var UserSearch = require('./UserSearch');
  var moment = require('moment');
  ```

  - We create a constructor function called `WeatherAdmin`. It is given a method of `getData` which will use the file system to read a `log.txt` file if it exists, and log that data to the console.

  ```js
  var WeatherAdmin = function() {
  this.getData = function() {
    fs.readFile("log.txt", "utf8", function(error, data) {
      console.log(data);
    });
  };
  ```

  - `WeatherAdmin` also gets a method of `newUserSearch`. This method takes in two arguments, name and location, much like our `UserSearch` constructor. This is so we can pass those two arguments along into the `UserSearch` constructor, as this method will instantiate a new `UserSearch` object and save it to a variable of `newUserSearch`.

  ```js
  this.newUserSearch = function(name, location) {
    var newUserSearch = new UserSearch(name, location);
  ```

  - We set our `logTxt` variable to equal a string we build that will display the name, location, and date of the search. We then call `moment` to get the date, and format it to `MM-DD-YYYY`.

  ```js
  var logTxt =
    '\nName: ' +
    newUserSearch.name +
    ' Location: ' +
    newUserSearch.location +
    ' Date: ' +
    moment(newUserSearch.date).format('MM-DD-YYYY');
  ```

  - We use the `fs.appendFile` method to append the current value of `logTxt` to our `log.txt` file.

  ```js
  fs.appendFile('log.txt', logTxt, function(err) {
    if (err) throw err;
  });
  ```

  - Next we call the `getWeather` method on our `newUserSearch` object.

  ```js
  newUserSearch.getWeather();
  ```

  - Finally we export our `WeatherAdmin` constructor.

  ```js
  module.exports = WeatherAdmin;
  ```

- Open [04-Stu_Weather-Admin/Solved/CLI.js] in your IDE and explain the following points:

  - ðŸ”‘First we require our WeatherAdmin export from `WeatherAdmin.js`

  ```js
  const WeatherAdmin = require('./WeatherAdmin');
  ```

  - We use `process.argv`, taking the 3rd argument to find out if the value is `admin` or `user`.

  ```js
  const loginType = process.argv[2];
  ```

  - We also need `Users` to provide a name and location.

  ```js
  const userName = process.argv[3];
  const userLocation = process.argv[4];
  ```

  - We create an instance of the `WeatherAdmin`. If they are running it as an `admin`, run the `getData` method. If they are not an `admin`, we will run `newUserSearch` passing the arguments from the command line.

  ```js
  const myAdmin = new WeatherAdmin();

  if (loginType === 'admin') {
    myAdmin.getData();
  } else {
    myAdmin.newUserSearch(userName, userLocation);
  }
  ```

### BREAK

- (15 min)

### Instructor Do: Introduce Prototypes

- (15 min)

  - Objects, arrays, and primitives all have a `.prototype.`

  - The `.prototype.` has methods and properties attached to it.

  - Methods declared on the prototype are declared once and memory is allocated for them once, but all objects made from it have access.

  - Instance methods only exist on a particular instance of an object, prototype methods are on all instances.

- Open [05-Ins_Prototypes/prototype-demo.js] in your IDE, and then open your browser and the Chrome Dev Tools. Copy and paste each code block into your dev tools and explain the following.

  - We create an array, and console log it. Next, we call the `.forEach` and `.map` methods on it.

  ```js
  myArray = [2, 4, 6, 8];
  console.log(myArray);

  myArray.forEach(num => console.log(num));

  myArray.map(x => console.log(x * 2));
  ```

  - Next we console log the string `Hello`. We then call `"Hello.toLowerCase"`

  ```js
  console.log('Hello');
  console.log('Hello'.toLowerCase());

  console.log(1337);
  console.log((1337).toString());
  ```

  - Where did the `.toLowerCase` come from?

  - While those two methods did not show up when we console logged our string, the prototype has these methods built in. Arrays, Objects, even primitives all have a prototype which they take their structure and methods from. Any of of these that you create will have the prototype methods available to it via the `.prototype.`. i.e., `Array.prototype.forEach()`

  - We created a constructor function named `Movie`, which will take in two arguments, `title` and `releaseYear`.

  ```js
  function Movie(title, releaseYear) {
    this.title = title;
    this.releaseYear = releaseYear;
  }
  ```

  - What if we wanted to add a method to our constructor later on in our code?

  - We would add that method to the `Movie.prototype`.

  - We declare the title of our method, which will be `logInfo`. We do so by typing `Movie.prototype.logInfo = function(){}`. We can only add to our constructor via the object prototype. When we add a method to an object's prototype, all the objects made from it will get it. If there is something thatâ€™s going to be the same between objects, and isnâ€™t going to change, it should be on the prototype. If it is defined on the prototype it is only defined once, and memory for it is only allocated once.

  ```js
  Movie.prototype.logInfo = function() {
    console.log(`${this.title} was released in ${this.releaseYear}`);
  };
  ```

  - When we create a new object via our `Movie` constructor, it will have access to all the methods defined in the constructor, and those that have been added to its prototype.

  ```js
  const theShining = new Movie('The Shining', 1980);
  theShining.logInfo();
  ```

  - Objects also have their own prototype methods built in. Even though our object was created via a constructor function, it still has access to all the built in object prototype methods.

  ```js
  console.log(theShining.hasOwnProperty('title'));
  console.log(theShining.hasOwnProperty('logInfo'));
  console.log(Movie.prototype.hasOwnProperty('logInfo'));
  ```

  - What does the Object Prototype allow us to do?

  - It allows us to reuse properties and methods between objects that need to share them. i.e., all movies can share the same `logInfo` methods, but get their own unique name and release year.

- Use the discussion to transition to the next topic.

### Student Do: RPG Prototype

- (20 min)

- Direct students to the next activity, located in [06-Stu_RPG-Prototypes].

### Instructor Do: Review

- (10 min)

- Open [06-Stu_RPG-Prototypes/Solved/rpg-prototypes.js] in your IDE and explain the following to students:

  - We create a `Character` constructor that will take in 6 arguments. We assign those arguments to keys in our constructor.

  ```js
  function Character(name, profession, gender, age, strength, hitpoints) {
    this.name = name;
    this.profession = profession;
    this.gender = gender;
    this.age = age;
    this.strength = strength;
    this.hitpoints = hitpoints;
  }
  ```

  - We add an `isAlive` function to our object prototype.

  ```js
  Character.prototype.isAlive = function() {
    {
    }
    console.log(this.name + ' has died!');
    return false;
  };
  ```

  - We also add two other functions to our `prototype`. The `attack` method takes in a second object and decreases their "hitpoints" by this character's strength. The `levelUp` method increases `this` character's stats when called.

  ```js
  Character.prototype.attack = function(character2) {
    character2.hitpoints -= this.strength;
  };

  Character.prototype.levelUp = function() {
    this.age += 1;
    this.strength += 5;
    this.hitpoints += 25;
  };
  ```

  - Finally we can use our constructor to create two characters, calling their methods from the prototype that we added.

  ```js
  var warrior = new Character('Crusher', 'Warrior', 'Male', 25, 10, 75);
  var rogue = new Character('Dodger', 'Rogue', 'Female', 23, 20, 50);

  warrior.printStats();
  rogue.printStats();

  rogue.attack(warrior);
  warrior.printStats();
  warrior.isAlive();

  rogue.levelUp();
  rogue.printStats();
  ```

  - Why don't we just declare the methods in the constructor?

  - When we bind a function using the `this` keyword, the method only exists on that instance of the object. For any method bound to `this`, it will be re declared with each new instance of an object.

  - How does the prototype help us solve this problem?

  - The prototype allows us to declare methods that will be attached to all instances of an object of that prototype. Because the method is applied to the prototype, it is only stored in memory once for all instances.

- Use the discussion to transition to the final activity of the day.

### Student Do: Tamagotchi App (25 min)

- Direct students to the final activity, located in [07-Stu_Tamagotchi].

### Instructor Do: Review

- (5 min)

- Open [07-Stu_Tamagotchi/Solved/tamagotchi.js] in your IDE and explain the following to students:

  - We first create a constructor function named `DigitalPal`. It takes no arguments as the value of the keys are predefined.

  ```js
  var DigitalPal = function() {
    this.hungry = false;
    this.sleepy = false;
    this.bored = true;
    this.age = 0;
  };
  ```

  - We create a function `feed` and attach it to the `.prototype.`. The method `feeds` the DigitalPal when they are hungry and sets them to sleepy

  ```js
  DigitalPal.prototype.feed = function() {
    if (this.hungry) {
      console.log('That was yummy!');
      this.hungry = false;
      this.sleepy = true;
    } else {
      console.log("No thanks, I'm full.");
    }
  };
  ```

  - We create a method called `sleep`, which puts the DigitalPal to sleep when they are sleepy. It also invokes the `increaseAge` function.

  ```js
  DigitalPal.prototype.sleep = function() {
    if (this.sleepy) {
      console.log('ZZzzZZZzzZZz~~');
      this.sleepy = false;
      this.bored = true;
      this.increaseAge();
    } else {
      console.log("No way! I'm not tired!");
    }
  };
  ```

  - We create a method called `play` which allows the user to play with their DigitalPal when they are bored and sets hungry to `true` and bored to `false.`

  ```js
  DigitalPal.prototype.play = function() {
    if (this.bored) {
      console.log("Yay! Let's play!");
      this.bored = false;
      this.hungry = true;
    } else {
      console.log('Not right now. Maybe later?');
    }
  };
  ```

  - This is the `increaseAge` method which is called within our `sleep` method. It will increase the age of our DigitalPal by one.

  ```js
  DigitalPal.prototype.increaseAge = function() {
    this.age++;
    console.log('Happy Birthday to me! I am ' + this.age + ' old!');
  };
  ```

  - The `destroyFurniture` will allow us to decrease our `houseQuality`.

  ```js
  DigitalPal.prototype.destroyFurniture = function() {
    if (this.houseQuality - 10 > 0) {
      this.houseQuality -= 10;
      this.bored = false;
      this.sleepy = true;
      console.log('MUAHAHAHAHA! TAKE THAT FURNITURE!');
    } else {
      console.log("I've already destroyed it all!");
    }
  };
  ```

  - We create and attach a `letOutside` function to our prototype which will let our pet outside, and make them bark!

  ```js
  DigitalPal.prototype.letOutside = function() {
    if (!this.outside) {
      console.log('Yay! I love the outdoors!');
      this.outside = true;
      this.bark();
    } else {
      console.log("We're already outside though...");
    }
  };
  ```

  - We create and attach a `letInside` function to our prototype which will let our pet back inside.

  ```js
  DigitalPal.prototype.letInside = function() {
    if (this.outside) {
      console.log('Aww... Do I have to?');
      this.outside = false;
    } else {
      console.log("We're already inside though...");
    }
  };
  ```

  - Finally we can grab the command line arguments provided by the user and use store them in variables called `animal` and `method`.

  ```js
  var animal = process.argv[2];
  var method = process.argv[3];
  ```
