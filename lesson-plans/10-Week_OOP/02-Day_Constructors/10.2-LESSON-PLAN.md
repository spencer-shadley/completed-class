# 10.2 Lesson Plan: Test-Driven-Development

## Overview

Today's class introduces students to test-driven-development and unit testing JavaScript applications.

GitHub CI example: https://github.com/spencer-shadley/example-jest-ci/actions?query=workflow%3A%22Node+CI%22

## Learning Objectives

- Explain the benefits of test-driven-development

- Use unit tests before as a way to define code requirements for code that hasn't been written yet

- Write unit tests for pre-existing JavaScript functions

- Use mocks to test side effects such as reading/writing to the file system, printing to the console, and AJAX requests

- Use the Arrange, Act, Assert pattern to structure test code

### Instructor Do: Introduce Testing

- 630-40 (10 min)

  - How do you know if your code is working?

  - What if you change something? Do you re-check the entire application every time?

  - We can automate with tests and provide guarantees that code doesn't break anything

  - Tests also force better more readable code and really think about how your code will be consumed

  - This is not specific to web applications. Any software should have tests.

  - About 1/3rd of engineers at Tableau only write tests. If you enjoy this it could be a career path.

    - Test engineer can also used as a first step towards a developer role

  - Adding tests is a common first task at a company

### Students Do: TDD Research

- 640-50 (8 min)

- Work in pairs researching test driven development and its benefits

### Instructor Do: Review

- 650-55 (5 min)

  - What is test-driven-development?

  - Why is it helpful to write tests before writing application code?

    - Forces a clean API
    - Forces more comprehensive thought process to have been considered
    - Modular code, break it up into its pieces
      - Clear responsibilities divided across different files, functions or modules
      - Cohesive code - Colocated code has related functionality. It's not entangled or dependent on other parts of the codebase
    - Enables quickly making sure that any code you are working on is correct, slowly building up to to pass the tests
    - This also provides self-documenting usage examples. It's somewhat common to understand how something should work by first reading its unit tests

  - What are some drawbacks of TDD?

    - Might take longer
    - Might be difficult to write tests for problems we're uncertain of

  - It's a red flag when interviewing someone and they don't use TDD

* ### Students Do: 08-Stu_TDD-Dissect

- 655-705 (10 min)

### Instructor Do: Review

- 705-10 (5 min)

- We are using a module called `Jest` to write unit tests

- We've had a sneak peek in our pre-class drills using mocha at TDD

- `Jest` is similar and also follows BDD (Behavioral Driven Development)

  - The expected behavior, or functionality, is described and tested for

  - `describe` starts a test suite of related tests

  - `it` specifies an individual unit test - it should be focused on a specific behavior for a given unit of code

    - this is human readable - your grandmother should be able to understand what's it's testing for

  - `expect` asserts validation and will throw an error when it does not meet the validation (failing the test)

    - show https://jestjs.io/docs/en/expect

- Tests follow the AAA pattern - Arrange, Act, Assert

- We can run the tests with `npm run test`

  - This is a script we added inside `package.json`

    - Show just running `jest` (might need to do a global install)

    - Add `list-files` script with `ls`

  - This looks inside `test` for any files ending with `.test.js`

  - Fail a test

- Demo the other files

  - default parameters with `= value`

  - We can chain values because each function returns an arithmetic (show `index.js`)

### Students Do: 09-Stu_TDD

- 710-25 (15 min)

- write tests for three unimplemented functions

### Instructor Do: Review

- 725-30 (5 min)

- Can your grandma understand these tests?

- Do you think these are good tests?

  - Yes, if they fail, it means the code isn't doing what it should.

- Do you think these are _enough_ tests?

  - No, it doesn't account for things like empty strings, what should happen if given invalid arguments or edge cases like palindromes with different casing or spaces.

### Students Do: 10-Stu_Pass-Tests

- 730-40 (10 min)

- Implement the functions to get the tests to pass

### Instructor Do: Review

- 745-50 (5 min)

  - Writing tests before writing code helps us ensure that our code will work.

  - Writing tests first allows for more rapid development because we will not have to manually test our code.

  - Live code, three simple functions - show tests slowly passing

### Instructor Do: 11-Ins_Organizing-Tests

- 750-8 (5 min)

- Example of using Arrange, Act, Assert

- Positive, negative and exception tests

- In each, you can consider the average user, monkey and devil

- Show two source files

- Start with todoList tests (has positive, negative and exceptions)

### Students Do: 12-Stu_Structured-Tests

- 8-15 (15 min)

- test two constructors using AAA

### Instructor Do: Review

- 815-30 (10 min)

- check for exceptions using `toThrow` or `toThrowError` matchers

- why would we throw an error?

  - makes debugging what went wrong easier and we can code assuming axioms after checks

### BREAK

- 830-45 (15 min)

### Instructor Do: 13-Ins_Introduce-Mocks

- 845-55 (10 min)

- Use mocks for `console.log` example

- Start with demo of `index.js`

- then `logger.js`

  - this is called the "dynamic prototype pattern"

- Explain the black test (and only the black test)

  - Mocks can "spy" on functions to see if they are being called, prevent undesired side effects (writing a file) or unpredictable behavior (AJAX calls) or to limit how much our unit test covers

- Lots of shared code, beforeEach and afterEach

### Students Do: 14-Stu_First-Mock

- 855-910 (15 min)

- add spies to mock the `console.log` method from the daycare example

### Instructor Do: Review

- 910-20 (10 min)

  - Mocks are used to spy on methods we haven't written ourselves, often to prevent some side effect such as an AJAX request, writing to the console, or reading/writing to the filesystem from actually happening during a test.

  - Mocks can be spied on, i.e. we can keep track of mocked functions being called, and what arguments they're called with.

- Open [13-Ins_Introduce-Mocks/test/14-Stu_First-Mock/Solved/test/dayCare.test.js] file in your IDE and point out the following:

  ```js
  it("should not add a child over the 'ageLimit'", () => {
    const child = new Child("Tammy", 8);
    const dayCare = new DayCare();
  ```

  - By mocking `console.log`, we can prevent it from running and filling up our terminals when running tests. We're able to spy on the `console.log` method and verify that it was called with the arguments we expect.

  ```js
  const mock = jest.spyOn(console, 'log');
  mock.mockImplementation(() => {});

  dayCare.addChild(child);

  expect(dayCare.children.length).toEqual(0);
  expect(mock).toBeCalledWith(
    'Unable to add child, they are over the age limit'
  );
  ```

  - We can "unmock" `console.log` by using the `mock.mockRestore` method. It's a good idea to clean up any mocks we run at the end of a test to ensure the next test isn't affected.

  ```js
  mock.mockRestore();
  ```

### Instructor Do: 15-Ins_Module-Mock-Demo

- 920-25 (5 min)

  - There are a few extra steps required to mock third party and built-in node modules, but the idea is the same.

- Open [15-Ins_Module-Mock-Demo/movieSearch.js] file in your IDE and point out the following:

  - This file exports a `MovieSearch` constructor that can be used to create an object used for searching the OMDB API.

  ```js
  const axios = require('axios');

  function MovieSearch() {}

  MovieSearch.prototype.buildUrl = function(movie) {
    return `https://www.omdbapi.com/?t=${movie}&apikey=trilogy`;
  };

  MovieSearch.prototype.search = function(movie) {
    return axios.get(this.buildUrl(movie));
  };
  ```

- Open [15-Ins_Module-Mock-Demo/test/movieSearch.test.js] file in your editor and point out the following key points:

  - We require axios and mock it, since we want to prevent actual AJAX requests from happening. This is one way of mocking a node module.

  ```js
  const axios = require('axios');
  const MovieSearch = require('../movieSearch');

  jest.mock('axios');
  ```

  - We mock the return value of `axios.get` to be a new Promise object that resolves to an object that contains a `data` property that's set to an empty object. We're mocking the return value to this because it's similar to what we would get from the response from the OMDB API.

  ```js
  it('should search the OMDB API for a given movie', () => {
    const movie = new MovieSearch();
    const name = 'Rocky';

    axios.get.mockReturnValue(
      new Promise(function(resolve) {
        resolve({ data: {} });
      })
    );

    expect(movie.search(name)).resolves.toEqual({ data: {} });
    expect(axios.get).lastCalledWith(movie.buildUrl(name));
  });
  ```

### Students Do: 16-Stu_Mock-Fs

- 925-35 (10 min)

### Instructor Do: Review

- 935-45 (10 min)

  - There are a few extra steps required to mock third party and built-in node modules, but the idea is the same.

  - By mocking the fs module we can avoid requiring our tests to read and write to the filesystem. Not only would this slow down tests, but it could influence how the next test runs.

- Open [16-Stu_Mock-Fs/Solved/test/fileIO.test.js] file in your editor and point out the following key points:

  - We mock the `fs` module by requiring it and using the `jest.mock` method at the top of the file.

  ```js
  const fs = require('fs');
  const FileIO = require('../fileIO');

  jest.mock('fs');
  ```

  - Since `fileIO.read` returns the result of `fs.readFileSync`, we can mock it's return value and verify it was called with the expected arguments without actually making a trip to the filesystem.

  ```js
  it("should call fs.readFileSync with the passed in 'file' argument", () => {
    const fileIO = new FileIO();
    const file = 'message.txt';
    let data;

    fs.readFileSync.mockReturnValue('Hello World!');
    data = fileIO.read(file);

    expect(data).toEqual('Hello World!');
    expect(fs.readFileSync).lastCalledWith(file, 'utf8');
  });
  ```

  - When testing the `fileIO.write` method, we just need to know that the `fs.writeFileSync` method was called with the correct arguments. We aren't testing that the `fs` module works, only that it's being utilized as expected.

  ```js
  it("should call fs.writeFileSync with the passed in 'path' and 'data' arguments", () => {
    const fileIO = new FileIO();
    const path = 'message.txt';
    const data = 'Hello World!';

    fileIO.write(path, data);

    expect(fs.writeFileSync).lastCalledWith(path, data);
  });
  ```

- Answer any lingering questions about testing or mocks before dismissing the class.

# Reduced time

-17
