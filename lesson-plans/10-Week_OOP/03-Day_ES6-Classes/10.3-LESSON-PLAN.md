# 10.3 - ES6 Classes

## Overview

In this class, students will learn the benefits of OOP and learn how to apply many OOP practices to their JavaScript applications using ES6 classes.

- The primary focus of the class should be introducing students to OOP concepts. Let the students know that it's okay if the new syntax feels overwhelming. The purpose of this lesson is to help students get comfortable with working with code that's organized with OOP practices.

## Learning Objectives

- Implement ES6 class syntax to instantiate multiple instances of a single type of object.

- Construct subclasses that inherit features from a common ancestor class.

- Demonstrate "thinking in OOP" by using objects to control the flow of action in an application.

### Instructor Do: Welcome Students

- 10-1010 (10 min)

- Demo the mini-project word guesser (24)

- From an Object Oriented perspective, what are three objects we could create to represent this application?

  - game, word, letter

- What kinds of methods could we have inside the `game` object?

  - operations like initializing game, prompt for letters, ending game, keeping track of guess count

- What kinds of methods could we have inside the `word` object?

  - printing

  - check if word matches solution

- What kinds of methods could we have inside the `letter` object?

  - Display that character ( \_ or letter)

  - The purpose of pseudocoding here is to practice organizing our code in a way that models real life objects.

- Save the pseudocode file and keep it handy so that you can refer to it in the second half of class.

- Take a moment and look around the room. What kinds of objects are in this room and what kinds of properties/methods could they have?

  - A student might have the method `completeActivities`.

- In today's class, we'll be implementing the ES6 class syntax, but we're also going to focus on modeling our code in an object oriented way. This helps us keep our code modular, reusable, and oftentimes simple, since objects in our code can closely resemble objects in the real world.

### Students Do: 17-Stu-Prototype-Review

- 1010-25 (15 min)

- add a new prototype function to search for an actor (given search for a show)

### Instructor Do: Review

- 1025-30 (5 min)

### Instructor Do: 18-Ins-Classes

- 1030-40 (10 min)

- start with `shape.js`

- use lightbulb to conver to ES6 class

- changes

  - special function called `constructor`

  - class methods removes the `function` keyword, instead of `.prototype` or arrows

  - inheritance is still prototypical instead of classical, it's just syntactic sugar

### Student Do: 19-Stu-Classes

- 1040-55 (15 min)

- RPG game using the new class constructor syntax

### Instructor Do: Review

- 1055-11 (5 min)

### Instructor Do: 20-Ins-Subclasses

- 11-1110 (10 min)

- start with `shape`

- `rectangle` takes in different args and then calls `super()` on computed stuff

- when extending a class you must call `super` before using `this`

- `super` calls the parent constructor

- `super` can also be used to access methods and properties from the parent class

- rectangles have `printInfo` because it was inherited from `Shape`

  - draw prototype chain on whiteboard

- this was an internship interview question I had at HomeAway

### Student Do: 21-Stu-Subclasses

- 1110-25 (15 min)

- Create a class inheritance structure with vehicles (cars and boats)

### Instructor Do: Review

- 1125-30 (5 min)

- We use `crewSoundOff` to do something different with our passengers.

### Instructor Do: 22-Ins-Multiple-Classes

- 1130-35 (5 min)

- start with `item.js`

- then `order.js`

  - an order contains one item

  - we generate an id

  - `Order.lastId` is a **static** value. There is only one available across all instances - one per class

- then `restaurant.js`

  - We create a new restaurant called "McJared's" and create three items.

  - Then, we map over each item, creating a new order.

  - Lastly, we use `orders.forEach` to take each order and prepare all of the orders once we're finished taking orders.

  ```js
  const restaurant = new Restaurant("McJared's");

  const items = [
    new Item('Burger', 5.99),
    new Item('Soda', 3.5),
    new Item('Chips', 2.0)
  ];

  const orders = items.map(item => new Order(item));

  orders.forEach(order => restaurant.takeOrder(order));

  restaurant.prepareOrders();
  ```

  - Why did we only call `prepareOrders` once?

  - `prepareOrders` continues to prepare orders until `restaurant.orders.length === 0`.

  - Why do we have all of our initialization and method execution in the `restaurant.js` file and not inside `item.js` or `order.js`?

  - Separation of concerns. Our code is easier to navigate if we give each class a clear responsibility. `Restaurant` is in charge of all operational things within the restaurant, whereas `Order` and `Item` are lightweight constructors.

### Student Do: Multiple Classes

- 1135-55 (20 min)

- Direct students to the instructions found in [23-Stu-Multiple-Classes]

### Instructor Do: Review

- 1155-12 (5 min)

- Run [23-Stu-Multiple-Classes/Solved/index.js] in your terminal and run the following:

  - `npm install`

  - `npm start`

  - Notice that the Rare Toy can only be purchased once before it goes out of stock. We can continue to purchase Rare Toys by using our `replenishStock` method.

- Open [23-Stu-Multiple-Classes/Solved/index.js] in your IDE and explain the following:

  - We purposely purchase enough Rare Toys to make sure that we get a message upon running out of stock.

  ```js
  store.welcome();
  store.processProductSale('Action Figure');
  store.processProductSale('Action Figure');
  store.processProductSale('Rare Toy');
  store.processProductSale('Action Figure');

  store.processProductSale('Rare Toy');

  store.replenishStock('Rare Toy', 2);
  store.processProductSale('Rare Toy');

  store.printRevenue();
  ```

- Open [23-Stu-Multiple-Classes/Solved/store.js] in your IDE and explain the following:

  - We use the name and stock arguments passed in through `new Store` and set the revenue to start at 0.

  - In `processProductSale`, we loop through each stock item in our Store. Once we've found one with a name that matches the name of the product we want to process, we decrease its count by one and increase the store's revenue by the price of the item.

  - In `replenishStock` we find the matching item by name and increase its count by the specified number.

  ```js
  class Store {
  constructor(name, stock) {
    this.name = name;
    this.stock = stock;
    this.revenue = 0;
  }

  processProductSale(name) {
    this.stock.forEach((item) => {
      if(item.name === name) {
        if(item.count > 0) {
          item.count--;
          this.revenue += item.price;
          console.log(`Purchased ${item.name} for ${item.price + item.calculateTax()}`)
        }
        else {
          console.log(`Sorry, ${item.name} is out of stock!`);
        }
      }
    })
  }

  replenishStock(name, count) {
    this.stock.forEach((item) => {
      if(item.name === name) {
        item.count += count;
        console.log(`Replenished ${item.name} by ${item.count}`)
      }
    })
  }
  ```

  - Why did we write our store initialization and product processing in a separate file called `index.js` instead of including it inside `store.js`?

  - We break away from `store.js` in this activity so that we can run isolated unit tests. If we were to include all of our method calls in `store.js`, then trying to test individual methods in `store.js` would **also** cause all of the method calls to run.

### BREAK

- 12-40 (40 min)

### Instructor Do: Introduce Mini Project

- 1240-45 (5 min)

- In your terminal, navigate to [24-Mini-Project/Solved], run `node index.js` and demonstrate the following:

- Take a moment to try playing a game of word guess. In order to properly demonstrate a won game, it is recommended that you use `word.js` to guide your guesses.

  - We get different responses depending on whether or not our guess was successful.

  - If we guess correctly or run out of guesses, the game is over.

  - Lastly, we can choose to play another game or quit.

- Answer any lingering questions students have about the functionality of the app.

### Student Do: Mini Project

- 1245-145 (60 min)

- Direct students to the instructions found in [24-Mini-Project]

- If there are students struggling to get started, bring up the pseudocode from earlier and recommend that they start with the smallest pieces first.

### Instructor Do: Review

- 145-55 (10 min)

- Open [24-Mini-Project/Solved/index.js] in your IDE and explain the following:

  - All we're doing here is initializing a new game with the Game Class from `Game.js`.

  ```js
  const game = new Game();

  game.play();
  ```

- Open [24-Mini-Project/Solved/Letter.js] in your IDE and explain the following:

  - The Letter Class is responsible for displaying either an underscore or the underlying character for each letter in the word.

  - In the constructor, we determine if a character is not a number or a letter, and if not, make it visible right away.

  ```js
  class Letter {
    constructor(char) {

      this.visible = !/[a-z1-9]/i.test(char);
      this.char = char;
    }
  ```

  - If the character should not be visible, return an underscore.

  ```js
    toString() {
      if (this.visible ) {
        return this.char;
      }
      return "_";
    }

    getSolution() {
      return this.char;
    }
  ```

  - We transform the character and the guess to uppercase so that the guess is case insensitive.

  ```js
    guess(charGuess) {
      if (charGuess.toUpperCase() === this.char.toUpperCase()) {
        this.visible = true;
        return true;
      }

      return false;
    }
  }

  module.exports = Letter;
  ```

- Open [24-Mini-Project/Solved/Word.js] in your IDE and explain the following:

  - In the constructor, we create a new `Letter` object for each character in the word string.

  - `getSolution` returns a string of all of the solved letters.

  ```js
  class Word {
    constructor(word) {
      this.letters = word.split("").map(function(char) {
        return new Letter(char);
      });
    }

    getSolution() {
      return this.letters
        .map(function(letter) {
          return letter.getSolution();
        })
        .join("");
    }

    toString() {
      return this.letters.join(" ");
    }
  ```

  - `guessLetter` checks to see if the user guessed correctly, then prints the word guessed so far.

  ```js
    guessLetter(char) {
      let foundLetter = false;
      this.letters.forEach(function(letter) {
        if (letter.guess(char)) {
          foundLetter = true;
        }
      });

      console.log("\n" + this + "\n");
      return foundLetter;
    }
  ```

  - `guessedCorrectly` uses `.every` to only return true if `letter.visible` is true for every letter.

  ```js
    guessedCorrectly() {
      return this.letters.every(function(letter) {
        return letter.visible;
      });
    }
  }

  module.exports = Word;
  ```

- Open [24-Mini-Project/Solved/Game.js] in your IDE and explain the following:

  - The Game constructor is responsible for keeping score and controlling the flow of the overall game.

  - We define the `play` function to initialize a new game with a different word.

  - `nextWord` grabs a random word from `words.js` and prompts the user for a guess.

  ```js
  class Game {
    constructor() {
      this.guessesLeft = 0;
    }
    play() {
      this.guessesLeft = 10;
      this.nextWord();
    }

    nextWord() {
      const randWord = words[Math.floor(Math.random() * words.length)];
      this.currentWord = new Word(randWord);
      console.log("\n" + this.currentWord + "\n");
      this.makeGuess();
    }
  ```

  - `makeGuess` prompts the user for a guess. If they have no guesses remaining, show them the solution, then ask if they want to play again.

  - If the user guessed the word correctly, we reset the guesses and prompt them with another word.

  ```js
    makeGuess() {
      this.askForLetter().then(() => {
        if (this.guessesLeft < 1) {
          console.log(
            'No guesses left! Word was: "' +
              this.currentWord.getSolution() +
              '"\n'
          );
          this.askToPlayAgain();

        } else if (this.currentWord.guessedCorrectly()) {
          console.log("You got it right! Next word!");
          this.guessesLeft = 10;
          this.nextWord();

        } else {
          this.makeGuess();
        }
      });
    }
  ```

  - `askToPlayAgain` prompts the user to play again. If they do not, we exit the node process.

  ```js
    askToPlayAgain() {
      inquirer
        .prompt([
          {
            type: "confirm",
            name: "choice",
            message: "Play Again?"
          }
        ])
        .then(val => {
          if (val.choice) {
            this.play();
          } else {
            this.quit();
          }
        });
    }
  ```

  - `askForLetter` is in charge of prompting users for letters, then running `guessLetter` to determine whether or not they've guessed correctly.

  ```js
    askForLetter() {
      return inquirer
        .prompt([
          {
            type: "input",
            name: "choice",
            message: "Guess a letter!",
            validate: function(val) {
              // The users guess must be a number or letter
              return /[a-z1-9]/gi.test(val);
            }
          }
        ])
        .then(val => {
          const didGuessCorrectly = this.currentWord.guessLetter(val.choice);
          if (didGuessCorrectly) {
            console.log(chalk.green("\nCORRECT!!!\n"));

          } else {
            this.guessesLeft--;
            console.log(chalk.red("\nINCORRECT!!!\n"));
            console.log(this.guessesLeft + " guesses remaining!!!\n");
          }
        });
    }
  ```
