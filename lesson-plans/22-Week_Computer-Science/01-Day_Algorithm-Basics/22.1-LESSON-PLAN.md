# 22.1 - Basics of Algorithms

## Overview

In this class, we will be introducing students to the fundamental concept of algorithm development and efficiency. We will then be leaving them with the remainder of class to work on projects.

`Summary: Complete activities 1-2 in Unit 22`

- [Visual Go](http://visualgo.net/) is a great resource for visualizing algorithms and data structures.

- [Show this linear search visualization](https://www.cs.usfca.edu/~galles/visualization/Search.html) around section 3.

- **Extra Resources:** Send out the following link before or after class and encourage students to tackle the algorithm questions in [Whiteboarding Overview and Questions](https://coding-bootcamp-whiteboarding-algorithms.readthedocs-hosted.com/en/latest/). This was given with the course pre-work but after this week, students should be able to accomplish those questions.

### Stu: Binary Search

- (25 min)

- Have students research the concept of "binary search".

- See if they can create their own method for creating a binary search based on their reading. They may find binary searches in other programming languagesâ€”or simply abstractly, allow them to try and create a binary search on their own.

### Ins: Binary Search Revealed

- (20 min)

- Explain binary search by analogy to finding words in a dictionary.

  - When looking for the word, say, _diaphanous_, one might open the dictionary to a random page, and see which section of the dictionary they end up in.

  - If they opened to the section for the letter H on page 100, they know to only look in the portion of the dictionary to the _left_ of page 100, and ignore the entire chunk of pages to the right.

  - Proceeding in this way allows them to quickly find the word they're looking for by discarding large, irrelevant portions of the search space.

- Open up `02-Binary-Search/Examples/binarySearch.js`, and walk students through its essential steps.

```js
function binarySearch(numbersArr, searchElement) {
  // Set some starting values.
  const currentElement;
  const currentIndex;
  const maxIndex = numbersArr.length - 1;
  const minIndex = 0;

  // This is the main loop.
  while (minIndex <= maxIndex) {
    // Get a position near the middle.
    currentIndex = Math.floor((minIndex + maxIndex) / 2);

    // Get that element.
    currentElement = numbersArr[currentIndex];

    // Test it.
    if (currentElement < searchElement) {
      // if it's less than we are looking for, look *above* this value.
      minIndex = currentIndex + 1;
    } else if (currentElement > searchElement) {
      // If it's more than we are looking for, look *below* this value.
      maxIndex = currentIndex - 1;
    } else {
      // We found it; return the index.
      return currentIndex;
    }
  }

  return false;
}
```

_The essential steps of the binary search algorithm._

- [Show this visualization](https://www.cs.usfca.edu/~galles/visualization/Search.html) to help students see what's going on, and to prompt questions.

  - [Visual Go](http://visualgo.net/bst) has another beautiful animation, which you may prefer to use.

- Point out that what makes this code effective is that we pre-sort a list of numbers in a range. Then, in each round, we check if the number we're trying is less than or more than the random number. Based on that we can effectively "halve" the number of options we still need to try.

- Ask when this code might be less efficient.

- Answer: Large, unsorted lists, which we would first have to sort and then search (O(n log n)). In this case, direct linear search is faster (O(n)).

```
* Of course, in practice, the one-time cost incurred by sorting might be worth it to enable algorithms that assume sorted input.
```

- Point out that binary search is _fast_. If we double the size of the input array, it will take longer, but it will _not_ increase by a factor of two.

- Point out that this is an example of a non-linear time complexity.

- For the curious, feel free to point out that binary search is O(log n).

```
* Reassure less confident students that this isn't a crucial detail at the moment.
```

### Stu: Project Work (Remainder)

- If time allows:

- Ask a student to define the word algorithm.

- Ask a student to explain how they might choose, _objectively_, between two different algorithms.

- Answer: Benchmarking/timing running time.

- Ask students what the time complexity is for an algorithm that takes twice as long to run if you double the size of its input; three times as long if you triple the size of its input; etc.

  - Linear.

- Ask a student to explain why binary search is so fast.

- Answer: Because it halves the search space on each iteration.

- Ask a student to name one essential difference between binary search and linear search.

- Answer: Time complexity. At worst, linear search will always take longer than binary search.

- Ask a student to explain when one might use binary search.

- Answer: When searching in a sorted array; or, when we have the option of sorting the array before we search.

- Ask a student to explain when one might opt for linear search.

- Answer: when searching in an unsorted array in situations where we _can't_ sort the array first.

```
 * E.g., when searching an array of elements on which no ordering can be imposed. An array filled with different data types is a good example.
```

- Address questions as they arise.

- If none do, slack out the link to [Interview Bit](http://www.interviewbit.com/).

  - Encourage them to spend at least ten minutes a day working on these questions, even after (maybe **especially** after!) finishing the Boot Camp.

  - Reassure them that this isn't _necessary_, but will drastically boost their confidence for technical interviews in the future.

- Allow students to work on projects for the remainder of the class period.
