# 22.1 - Basics of Algorithms

## Overview

In this class, we will be introducing students to the fundamental concept of algorithm development and efficiency. We will then be leaving them with the remainder of class to work on projects.

`Summary: Complete activities 1-2 in Unit 22`

- [Visual Go](http://visualgo.net/) is a great resource for visualizing algorithms and data structures.

- [Show this linear search visualization](https://www.cs.usfca.edu/~galles/visualization/Search.html) around section 3.

- **Extra Resources:** Send out the following link before or after class and encourage students to tackle the algorithm questions in [Whiteboarding Overview and Questions](https://coding-bootcamp-whiteboarding-algorithms.readthedocs-hosted.com/en/latest/). This was given with the course pre-work but after this week, students should be able to accomplish those questions.

### Ins: Time a MUCH LARGER Search

- (1 min)

- Reopen `linearSearch.js`, and change the value of `length` to `1000000000`.

- Have students explain the difference between this code and the old code. Ask a couple of students if this code should be faster; slower; or just as fast as the previous code. Why?

  - Essentially, the only difference is we've _increased_ the number of elements in our array, which _decreases_ the probability we'll find our `random_value` in any given iteration.

  - This code should take longer to run, because there's a lower chance our loop will find the right number on each iteration.

### Stu: Time The Search

- (2 min)

- Now have students re-time their search. Their old code will work for this example as well.

  - Sufficiently large values of `length` will cause `heap size exceeded` errors. If/when students run into this, have them run the benchmark with the following command:

    - `node --max-old-space-size=4096 linearSearch.js`

```
* Explain that this increases the amount of space available for the Node process.

* Alternatively, they can simply reduce `length` until the error disappears. They'll still get a big enough value to illustrate that this code takes longer.
```

- Point out that now the code starts to take longer, and now we're beginning to see the limitations of our "linear approach".

_Results of running benchmarks on a Dell Envy w/ Intel i7 2.7GHz and 16Gb RAM._

- Ask students the max number of steps (or instructions) it would take to solve this.

  - Answer: 1000000000, or `length`.

### Everyone Do: How Could We Improve?

- (12 min)

* Explain that, as developers, our primary concerns are choosing the algorithm that runs most quickly.

  - Feel free to mention space efficiency, as well. Be aware that we have no exercises for space efficiency, so don't get too sidetracked if you decide to mention it.

* Point out that we've discussed two ways to sort a list.

* Emphasize that this demonstrates that there are often multiple approaches to solving the same problems.

  - Explain that some of those approaches are better than others, depending on the problem we're trying to solve.

* Have students try to pseudocode or research a better approach.

  - Students shouldn't be coding at this point—simply thinking of ways to come up with a better solution.

### Stu: Binary Search

- (25 min)

- Have students research the concept of "binary search".

- See if they can create their own method for creating a binary search based on their reading. They may find binary searches in other programming languages—or simply abstractly, allow them to try and create a binary search on their own.

### Ins: Binary Search Revealed

- (20 min)

- Explain binary search by analogy to finding words in a dictionary.

  - When looking for the word, say, _diaphanous_, one might open the dictionary to a random page, and see which section of the dictionary they end up in.

  - If they opened to the section for the letter H on page 100, they know to only look in the portion of the dictionary to the _left_ of page 100, and ignore the entire chunk of pages to the right.

  - Proceeding in this way allows them to quickly find the word they're looking for by discarding large, irrelevant portions of the search space.

- Open up `02-Binary-Search/Examples/binarySearch.js`, and walk students through its essential steps.

```js
function binarySearch(numbersArr, searchElement) {
  // Set some starting values.
  const currentElement;
  const currentIndex;
  const maxIndex = numbersArr.length - 1;
  const minIndex = 0;

  // This is the main loop.
  while (minIndex <= maxIndex) {
    // Get a position near the middle.
    currentIndex = Math.floor((minIndex + maxIndex) / 2);

    // Get that element.
    currentElement = numbersArr[currentIndex];

    // Test it.
    if (currentElement < searchElement) {
      // if it's less than we are looking for, look *above* this value.
      minIndex = currentIndex + 1;
    } else if (currentElement > searchElement) {
      // If it's more than we are looking for, look *below* this value.
      maxIndex = currentIndex - 1;
    } else {
      // We found it; return the index.
      return currentIndex;
    }
  }

  return false;
}
```

_The essential steps of the binary search algorithm._

- [Show this visualization](https://www.cs.usfca.edu/~galles/visualization/Search.html) to help students see what's going on, and to prompt questions.

  - [Visual Go](http://visualgo.net/bst) has another beautiful animation, which you may prefer to use.

- Point out that what makes this code effective is that we pre-sort a list of numbers in a range. Then, in each round, we check if the number we're trying is less than or more than the random number. Based on that we can effectively "halve" the number of options we still need to try.

- Ask when this code might be less efficient.

- Answer: Large, unsorted lists, which we would first have to sort and then search (O(n log n)). In this case, direct linear search is faster (O(n)).

```
* Of course, in practice, the one-time cost incurred by sorting might be worth it to enable algorithms that assume sorted input.
```

- Point out that binary search is _fast_. If we double the size of the input array, it will take longer, but it will _not_ increase by a factor of two.

- Point out that this is an example of a non-linear time complexity.

- For the curious, feel free to point out that binary search is O(log n).

```
* Reassure less confident students that this isn't a crucial detail at the moment.
```

### Stu: Project Work (Remainder)

- If time allows:

- Ask a student to define the word algorithm.

- Ask a student to explain how they might choose, _objectively_, between two different algorithms.

- Answer: Benchmarking/timing running time.

- Ask students what the time complexity is for an algorithm that takes twice as long to run if you double the size of its input; three times as long if you triple the size of its input; etc.

  - Linear.

- Ask a student to explain why binary search is so fast.

- Answer: Because it halves the search space on each iteration.

- Ask a student to name one essential difference between binary search and linear search.

- Answer: Time complexity. At worst, linear search will always take longer than binary search.

- Ask a student to explain when one might use binary search.

- Answer: When searching in a sorted array; or, when we have the option of sorting the array before we search.

- Ask a student to explain when one might opt for linear search.

- Answer: when searching in an unsorted array in situations where we _can't_ sort the array first.

```
 * E.g., when searching an array of elements on which no ordering can be imposed. An array filled with different data types is a good example.
```

- Address questions as they arise.

- If none do, slack out the link to [Interview Bit](http://www.interviewbit.com/).

  - Encourage them to spend at least ten minutes a day working on these questions, even after (maybe **especially** after!) finishing the Boot Camp.

  - Reassure them that this isn't _necessary_, but will drastically boost their confidence for technical interviews in the future.

- Allow students to work on projects for the remainder of the class period.
