# 22.2 - Sorting Algorithms

### Deck

- 630-7 (30 min)

- Complete the remainder of 21.1 deck

### Stu: Sorting By Hand

- 7-10 (10 min)

- raise your hand when you finished sorting by hand

- ask: how'd you sort them?

  - where did you start in the list?

  - what did you do with the first number?

  - how did you compare numbers?

  - what if there were 1,000 numbers?

### Bubble Sort, Selection Sort and Insertion Sort

- 710-40 (30 min)

- I'm going to quickly go over five sorting algorithms

  - these are the easy ones to comprehend but you won't see any of them in practice

  - there are bonus activities for each of these if you'd like more in-depth examples

- `Bubble Sort`

  - it's horrible but very human-friendly

  - https://visualgo.net/en/sorting

  - if the adjacent number is larger, swap it until the end of the list

  - demo with deck of cards

  - each iteration sorts one item

  - ask: what's the complexity? (O(N^2))

  - probably the simplest sort out there, also infamously one of the worst - just showing for demo purposes

- `selection sort`

  - bonus-selection-sort if you want more info

  - find the smallest number

  - this is our first number

  - find the second smallest number

  - this is our second number

  - ...

  - demo with cards and then with https://visualgo.net/en/sorting

  - ask: Big O? O(N^2)

- `Insertion Sort`

  - https://visualgo.net/en/sorting

  - cards and then visualization

  - still O(N^2) average and worst

  - best case is now O(N) and is in-practice a bit faster

- `Monkey Sort`

  - my favorite sort

  - shuffle the array randomly

  - if it's sorted, you're done. Otherwise re-shuffle.

- `Sleep Sort`

  - wait the amount of time of value in the array and then insert that into the new array

- ask: which of these is best?

  - they're all terrible

- ask: does anyone know of better sorting algorithms?

  - mergesort, quicksort, heapsort

### Ins: Quick-Sort

- (15 min)

- this is a much harder sort to comprehend

- the others were intuitive and, as a result, tend to have simple code

- we can trade code complexity for performance

- created because insertion sort was too slow

  - `Array.sort` will sometimes use QuickSort and sometimes use MergeSort (depending on data)

  - Mozilla uses MergeSort and Chromium uses a mix of insertion sort and quick sort

    - WebKit numeric arrays use std::qsort (quick sort)

    - contiguous non-numeric arrays use mergesort

    - the non-contiguous arrays use selection sort or an AVL tree

- quick sort is all about pivots

  - pick a random pivot (location doesn't matter)

  - remove pivot from array (swap with ending element)

  - find the first item from the left that is larger than pivot

  - find the first item from the right that is smaller than pivot

  - repeat until index of the item from the left is greater than the index of the item from the right

  - swap itemFromLeft with pivot

  - all items to the left of pivot are smaller

  - all items to the right of pivot are larger

  - recurse

### MergeSort

- FireFox uses MergeSort - https://bugzilla.mozilla.org/show_bug.cgi?id=224128

### BREAK

- (15 min)

### Ins: Which is Best?

- (15 min)

* Ask students which algorithm they think is best.

* After hearing a few responses, answer the question for them: "It depends".

* Certain sorts are better in certain situations.

* Let them know the efficiencies of sorting algorithms depends on things like:

  - How big the data set is—insertion sort is a good default for small arrays.
  - How ordered the data is—i.e., whether it's completely out of order, or partially sorted.
  - How many unique elements there are.

* It's not obvious, but on average, quick-sort is _much_ faster in practice than either insertion or selection sort.

  - But, insertion sort wins for small arrays, and for arrays that are already almost sorted.

* Next, open the file `JS Sort`, and point out that JavaScript has a built-in sort method for arrays, `sort()`.

* Point out that uses algorithm like these under the hood.

* Explain that different browsers have different JavaScript "engines", each written differently. So, the details of JavaScript's `sort()` method can differ from environment to environment.

* To point out a big project using quick-sort, [Chrome's V8 engine uses quick-sort for general arrays, and Insertion sort for arrays with fewer than 10 elements](https://github.com/v8/v8/blob/master/src/js/array.js) (ca. 760-844).

* Demo the `05-Quicksort/Solutions/quickSortExample.js` file in your terminal to illustrate how much faster quick-sort is when dealing with large amounts of data.

### Stu: Sorting Algorithms Visuals

- (10 min)

* Have students spend a few moments looking at the [visuals on this page](http://www.sorting-algorithms.com/).

* Let them see for themselves that an algorithm's performance depends greatly on the initial conditions of its input.

  - Emphasize that **one's choice of algorithm depends on the expected input**.

### Stu: Pseudocode Quick-Sort (20 min.)

- Slack out the following instructions to students.

- **Instruction**:

- Write a (pseudocode!) implementation of quick-sort. You can assume that `partition` and `select_pivot` functions are already written for you.

- Keep in mind the idea of recursion: <https://en.wikipedia.org/wiki/Recursion_(computer_science)#Recursive_functions_and_algorithms>

- Don't sweat it if you're unsure of your solution—pseudocode affords a lot of freedom, and we'll review things together shortly. Regardless, be prepared to explain your work!

### Ins: Review

- Open up `05-Quicksort/Solutions/quicksort_pseudo.md`, and review the code.

- Focus on explaining the recursive nature of quick-sort.

- Ask a student, or row, to explain the recursion.

- Because `partition` puts the `pivot` where it will appear in the final, sorted array.

- Recursing repeats the process for each subarray, gradually putting `pivot`s in the right place.

- Reassure students that it's okay if this is still a bit confusing. They won't need to implement these algorithms soon, if ever.

- Regardless, encourage them to study on their own. Algorithms are a great way to become a better programmer.

- Keep in mind that this exercise is more concerned with fostering _algorithmic thinking_ than we are with correct implementation. Foster a discussion, and don't get mired in the details of implementing `partition`, etc.

#### Review

If you have time, review the following questions before allowing students to work on projects:

1. If you had to choose to always use insertion sort, or always use quick-sort, which would you choose?

   - Answer: Quick-Sort is faster in general, but the **choice depends on the input**.

2. When would you use insertion sort?

   - Answer: For small arrays, and for arrays that are almost sorted.

3. When would you use quick-sort?

   - Answer: For arrays that are likely to be mostly unsorted.

4. Why do we need to know something about our input before we choose a sort method?

   - Answer: The best choice in certain cases may be the worst in others. For example:
   - Insertion sort is faster than quick-sort for almost-sorted arrays.
   - But, insertion sort is _much_ slower than quick-sort for reversed arrays.

Address any questions that may arise.

1. If none do, slack out the link to [Interview Bit](http://www.interviewbit.com/).

2. Encourage them to spend at least ten minutes a day working on these questions, even after (maybe **especially** after!) finishing the Boot Camp.

3. Reassure them that this isn't _necessary_, but will drastically boost their confidence for technical interviews in the future.

4. Dismiss students to work on projects for the remainder of class.
